{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OroCommerce Cheatsheet","title":"Home"},{"location":"#orocommerce-cheatsheet","text":"","title":"OroCommerce Cheatsheet"},{"location":"backend/delete-entity/","text":"Sc\u00e9nario : Je supprimer une entit\u00e9 proprement Comment supprimer une entitt\u00e9 Vider le cache php app/console cache:clear -e dev Enlever les donn\u00e9es li\u00e9es \u00e0 l'entit\u00e9 en base app/console oro:entity-config:debug \"Acme\\Bundle\\YourBundle\\Entity\\YourEntity\" --attr=\"state\" --scope=\"extend\" --set --val=\"Deleted\" Enlever les donn\u00e9ee de l'entit\u00e9 propri\u00e9taire app/console oro:entity-config:debug \"Acme\\Bundle\\YourBundle\\Entity\\YourEntity\" --scope ownership --remove Mettre \u00e0 jour la config de l'entit\u00e9 app/console oro:entity-config:update Mettre \u00e0 jour la config de l'entit\u00e9 \u00e9tendu app/console oro:entity-extend:update-config Mettre \u00e0 jour le schema app/console oro:entity-extend:update-schema Un bash qui fait tout \u00e7a : echo -e \"bin / app\" read SF echo -e \"Chemin relatif de l'entit\u00e9 \u00e0 supprimer : \" echo -e \"Ex: Acme\\Bundle\\YourBundle\\Entity\\YourEntity\" read CHEMIN echo -e \"php \"$SF\"/console cache:clear -e dev\" $SF/console cache:clear -e dev echo -e \"oro:entity-config:debug \"$CHEMIN\" --attr='state' --scope='extend' --set --val='Deleted'\" $SF/console oro:entity-config:debug $CHEMIN --attr=\"state\" --scope=\"extend\" --set --val=\"Deleted\" echo -e \"oro:entity-config:debug \"$CHEMIN\" --scope ownership --remove\" $SF/console oro:entity-config:debug $CHEMIN --scope ownership --remove echo -e \"oro:entity-config:update\" $SF/console oro:entity-config:update echo -e \"oro:entity-extend:update-config\" $SF/console oro:entity-extend:update-config echo -e \"oro:entity-extend:update-schema\" $SF/console oro:entity-extend:update-schema","title":"Comment supprimer proprement une entit\u00e9"},{"location":"backend/delete-entity/#scenario","text":"Je supprimer une entit\u00e9 proprement","title":"Sc\u00e9nario :"},{"location":"backend/delete-entity/#comment-supprimer-une-entitte","text":"Vider le cache php app/console cache:clear -e dev Enlever les donn\u00e9es li\u00e9es \u00e0 l'entit\u00e9 en base app/console oro:entity-config:debug \"Acme\\Bundle\\YourBundle\\Entity\\YourEntity\" --attr=\"state\" --scope=\"extend\" --set --val=\"Deleted\" Enlever les donn\u00e9ee de l'entit\u00e9 propri\u00e9taire app/console oro:entity-config:debug \"Acme\\Bundle\\YourBundle\\Entity\\YourEntity\" --scope ownership --remove Mettre \u00e0 jour la config de l'entit\u00e9 app/console oro:entity-config:update Mettre \u00e0 jour la config de l'entit\u00e9 \u00e9tendu app/console oro:entity-extend:update-config Mettre \u00e0 jour le schema app/console oro:entity-extend:update-schema","title":"Comment supprimer une entitt\u00e9"},{"location":"backend/delete-entity/#un-bash-qui-fait-tout-ca","text":"echo -e \"bin / app\" read SF echo -e \"Chemin relatif de l'entit\u00e9 \u00e0 supprimer : \" echo -e \"Ex: Acme\\Bundle\\YourBundle\\Entity\\YourEntity\" read CHEMIN echo -e \"php \"$SF\"/console cache:clear -e dev\" $SF/console cache:clear -e dev echo -e \"oro:entity-config:debug \"$CHEMIN\" --attr='state' --scope='extend' --set --val='Deleted'\" $SF/console oro:entity-config:debug $CHEMIN --attr=\"state\" --scope=\"extend\" --set --val=\"Deleted\" echo -e \"oro:entity-config:debug \"$CHEMIN\" --scope ownership --remove\" $SF/console oro:entity-config:debug $CHEMIN --scope ownership --remove echo -e \"oro:entity-config:update\" $SF/console oro:entity-config:update echo -e \"oro:entity-extend:update-config\" $SF/console oro:entity-extend:update-config echo -e \"oro:entity-extend:update-schema\" $SF/console oro:entity-extend:update-schema","title":"Un bash qui fait tout \u00e7a :"},{"location":"backend/dynamic-action-datagrid/","text":"Sc\u00e9nario : L'affichage ou non d'une action doit \u00eatre g\u00e9n\u00e9r\u00e9e a la vol\u00e9e suivant les donn\u00e9es de la ligne G\u00e9rer dynamiquement des actions dans une datagrid Dans datagrid.yml properties: link_1: type: url route: route_1 params: [id] link_2: type: url route: route_2 params: [id] actions: action_1: type: navigate label: edit link: link_1 icon: edit rowAction: true action_2: type: navigate label: edit link: link_2 icon: edit rowAction: true action_configuration: ['@acme_test.datagrid.entity.action_permission_provider', 'getActionPermissions'] On fait le service du provider : acme_test.datagrid.entity.action_permission_provider: class: Acme\\Bundle\\TestBundle\\Datagrid\\EntityActionPermissionProvider La classe qui va avec : $record contient nos donn\u00e9es pour chaque ligne de la datagrid <?php namespace Acme\\Bundle\\TestBundle\\Datagrid; use Marello\\Bundle\\DataGridBundle\\Action\\ActionPermissionInterface; use Oro\\Bundle\\DataGridBundle\\Datasource\\ResultRecordInterface; class EntityActionPermissionProvider implements ActionPermissionInterface { /** * {@inheritdoc} */ public function getActionPermissions(ResultRecordInterface $record) { // Votre traitement qui va permettre de d\u00e9cider les actions qu'on affiche // false => pas affich\u00e9 // true => affich\u00e9 return [ 'action_1' => true, 'action_2' => false ]; } }","title":"G\u00e9rer dynamiquement des actions dans une datagrid"},{"location":"backend/dynamic-action-datagrid/#scenario","text":"L'affichage ou non d'une action doit \u00eatre g\u00e9n\u00e9r\u00e9e a la vol\u00e9e suivant les donn\u00e9es de la ligne","title":"Sc\u00e9nario :"},{"location":"backend/dynamic-action-datagrid/#gerer-dynamiquement-des-actions-dans-une-datagrid","text":"Dans datagrid.yml properties: link_1: type: url route: route_1 params: [id] link_2: type: url route: route_2 params: [id] actions: action_1: type: navigate label: edit link: link_1 icon: edit rowAction: true action_2: type: navigate label: edit link: link_2 icon: edit rowAction: true action_configuration: ['@acme_test.datagrid.entity.action_permission_provider', 'getActionPermissions'] On fait le service du provider : acme_test.datagrid.entity.action_permission_provider: class: Acme\\Bundle\\TestBundle\\Datagrid\\EntityActionPermissionProvider La classe qui va avec : $record contient nos donn\u00e9es pour chaque ligne de la datagrid <?php namespace Acme\\Bundle\\TestBundle\\Datagrid; use Marello\\Bundle\\DataGridBundle\\Action\\ActionPermissionInterface; use Oro\\Bundle\\DataGridBundle\\Datasource\\ResultRecordInterface; class EntityActionPermissionProvider implements ActionPermissionInterface { /** * {@inheritdoc} */ public function getActionPermissions(ResultRecordInterface $record) { // Votre traitement qui va permettre de d\u00e9cider les actions qu'on affiche // false => pas affich\u00e9 // true => affich\u00e9 return [ 'action_1' => true, 'action_2' => false ]; } }","title":"G\u00e9rer dynamiquement des actions dans une datagrid"},{"location":"backend/event-listener-datagrid-orm-result/","text":"Sc\u00e9nario : Je veux, pour chaque ligne (ORM results) d'une datagrid, faire des trucs. Cr\u00e9er l'Event Listener Placez-vous dans votre bundle et cr\u00e9ez ce fichier : Acme/Bundle/FooBundle/Listener/FooDatagridListener.php <?php namespace Acme\\Bundle\\FooBundle\\EventListener; use Oro\\Bundle\\DataGridBundle\\Datasource\\ResultRecord; use Oro\\Bundle\\DataGridBundle\\Event\\OrmResultAfter; use Oro\\Bundle\\EntityBundle\\ORM\\DoctrineHelper; use Acme\\Bundle\\FooBundle\\Entity\\Foo; class FooDatagridListener { /** * @param OrmResultAfter $event */ public function onResultAfter(OrmResultAfter $event) { /** @var ResultRecord[] $records */ $records = $event->getRecords(); // Nos r\u00e9sultats } } Cr\u00e9ez le service services: acme_foo.event_listener.foo_datagrid: class: 'Acme\\Bundle\\FooBundle\\EventListener\\FooDatagridListener' tags: - { name: kernel.event_listener, event: oro_datagrid.orm_datasource.result.after.foo-grid, method: onResultAfter } foo-grid est le nom de la grid a \u00e9couter On pourrait imaginer que nous ayons besoin de r\u00e9cup\u00e9rer tous les Ids pour les mettre dans un tableau /** * @param OrmResultAfter $event */ public function onResultAfter(OrmResultAfter $event) { $tableOfIds = []; /** @var ResultRecord[] $records */ $records = $event->getRecords(); foreach ($records as $record) { $tableOfIds[] = $record->getValue('id'); } }","title":"Orm Result"},{"location":"backend/event-listener-datagrid-orm-result/#scenario","text":"Je veux, pour chaque ligne (ORM results) d'une datagrid, faire des trucs.","title":"Sc\u00e9nario :"},{"location":"backend/event-listener-datagrid-orm-result/#creer-levent-listener","text":"Placez-vous dans votre bundle et cr\u00e9ez ce fichier : Acme/Bundle/FooBundle/Listener/FooDatagridListener.php <?php namespace Acme\\Bundle\\FooBundle\\EventListener; use Oro\\Bundle\\DataGridBundle\\Datasource\\ResultRecord; use Oro\\Bundle\\DataGridBundle\\Event\\OrmResultAfter; use Oro\\Bundle\\EntityBundle\\ORM\\DoctrineHelper; use Acme\\Bundle\\FooBundle\\Entity\\Foo; class FooDatagridListener { /** * @param OrmResultAfter $event */ public function onResultAfter(OrmResultAfter $event) { /** @var ResultRecord[] $records */ $records = $event->getRecords(); // Nos r\u00e9sultats } } Cr\u00e9ez le service services: acme_foo.event_listener.foo_datagrid: class: 'Acme\\Bundle\\FooBundle\\EventListener\\FooDatagridListener' tags: - { name: kernel.event_listener, event: oro_datagrid.orm_datasource.result.after.foo-grid, method: onResultAfter } foo-grid est le nom de la grid a \u00e9couter On pourrait imaginer que nous ayons besoin de r\u00e9cup\u00e9rer tous les Ids pour les mettre dans un tableau /** * @param OrmResultAfter $event */ public function onResultAfter(OrmResultAfter $event) { $tableOfIds = []; /** @var ResultRecord[] $records */ $records = $event->getRecords(); foreach ($records as $record) { $tableOfIds[] = $record->getValue('id'); } }","title":"Cr\u00e9er l'Event Listener"},{"location":"backend/event-listener-datagrid-structure/","text":"Sc\u00e9nario : Je veux modifer la structure d'une datagrid \u00e0 la vol\u00e9e Comment cr\u00e9er un EventListener pour modifier une DataGrid Placez-vous dans votre bundle et cr\u00e9ez ce fichier : YourName/Bundle/YourBundle/Listener/OnGridBuildAfterListener.php <?php namespace YourName\\Bundle\\YourBundle\\Listener; use Oro\\Bundle\\DataGridBundle\\Event\\BuildAfter; class OnGridBuildAfterListener { public function onBuildAfter(BuildAfter $event) { $config = $event->getDatagrid()->getConfig(); } } Cr\u00e9ez le service pour que la classe soit reconnue services: yourname_yourbundle.grid.after.listener: class: YourName\\Bundle\\TestBundle\\Listener\\OnGridBuildAfterListener tags: - { name: kernel.event_listener, event: oro_datagrid.datagrid.build.after.le-nom-de-votre-datagrid, method: onBuildAfter } L'objet $config contient toute la configuration de votre datagrid On accede aux propri\u00e9t\u00e9s grace a cette methode $config->offsetGetByPath(); Imaginons que notre datagrid contient une colonne avec le nom \"name\" et que nous voulons changer son label <?php namespace YourName\\Bundle\\YourBundle\\Listener; use Oro\\Bundle\\DataGridBundle\\Event\\BuildAfter; class OnGridBuildAfterListener { public function onBuildAfter(BuildAfter $event) { $config = $event->getDatagrid()->getConfig(); $newNameLabel = $config->offsetGetByPath(\"[columns][name]\"); $newNameLabel['label'] = 'Le nouveau label de la colonne name'; $config->offsetAddToArrayByPath(\"[columns][name]\", $newNameLabel); return; } } Maintenant le label de la colonne name est 'Le nouveau label de la colonne name' L'objet $config contient toute notre config, nous avons choisi de modifier une colonne, mais nous aurions pu modifier autre chose: Une action, un Filtre, etc..","title":"Structure"},{"location":"backend/event-listener-datagrid-structure/#scenario","text":"Je veux modifer la structure d'une datagrid \u00e0 la vol\u00e9e","title":"Sc\u00e9nario :"},{"location":"backend/event-listener-datagrid-structure/#comment-creer-un-eventlistener-pour-modifier-une-datagrid","text":"Placez-vous dans votre bundle et cr\u00e9ez ce fichier : YourName/Bundle/YourBundle/Listener/OnGridBuildAfterListener.php <?php namespace YourName\\Bundle\\YourBundle\\Listener; use Oro\\Bundle\\DataGridBundle\\Event\\BuildAfter; class OnGridBuildAfterListener { public function onBuildAfter(BuildAfter $event) { $config = $event->getDatagrid()->getConfig(); } } Cr\u00e9ez le service pour que la classe soit reconnue services: yourname_yourbundle.grid.after.listener: class: YourName\\Bundle\\TestBundle\\Listener\\OnGridBuildAfterListener tags: - { name: kernel.event_listener, event: oro_datagrid.datagrid.build.after.le-nom-de-votre-datagrid, method: onBuildAfter } L'objet $config contient toute la configuration de votre datagrid On accede aux propri\u00e9t\u00e9s grace a cette methode $config->offsetGetByPath(); Imaginons que notre datagrid contient une colonne avec le nom \"name\" et que nous voulons changer son label <?php namespace YourName\\Bundle\\YourBundle\\Listener; use Oro\\Bundle\\DataGridBundle\\Event\\BuildAfter; class OnGridBuildAfterListener { public function onBuildAfter(BuildAfter $event) { $config = $event->getDatagrid()->getConfig(); $newNameLabel = $config->offsetGetByPath(\"[columns][name]\"); $newNameLabel['label'] = 'Le nouveau label de la colonne name'; $config->offsetAddToArrayByPath(\"[columns][name]\", $newNameLabel); return; } } Maintenant le label de la colonne name est 'Le nouveau label de la colonne name' L'objet $config contient toute notre config, nous avons choisi de modifier une colonne, mais nous aurions pu modifier autre chose: Une action, un Filtre, etc..","title":"Comment cr\u00e9er un EventListener pour modifier une DataGrid"},{"location":"backend/handler-provider-update/","text":"Sc\u00e9nario : J'ai des besoins complexes de persitances d'entit\u00e9es et de r\u00e9ponses \u00e0 renvoyer \u00e0 la vue que le UpdateHandlerFacade ne peut satisfaire Le cas simple Ceci est l'update de Oro/Bundle/ProductBundle/Controller/BrandController. Il fonctionne assez simplement : On passe au update_handler - L'entit\u00e9 ($brand) - Le form - L'objet request - Une cha\u00eene de caract\u00e8re traduite \u00e0 afficher quand la sauvegarde est faite. protected function update(Brand $brand, Request $request) { return $this->get('oro_form.update_handler')->update( $brand, $this->createForm(BrandType::NAME, $brand), $this->get('translator')->trans('oro.product.brand.form.update.messages.saved'), $request, null ); } L'UpdateHandlerFacade s'occupe d'enregistrer la donn\u00e9e et de construire une r\u00e9ponse qui est renvoy\u00e9e a la vue. Le cas plus compliqu\u00e9 En utilisant la m\u00e9thode pr\u00e9cedente, on n'a ni la main sur la mani\u00e8re dont Oro persiste notre entit\u00e9e, ni sur la r\u00e9ponse qu'il va construire et renvoyer \u00e0 la vue. Le Handler Le handler permet de d\u00e9l\u00e8guer tout le traitement d'un formulaire. L'utilisation d'un handler \u00e0 nous : protected function update(Brand $brand, Request $request) { return $this->updateHandler->update( $brand, $this->createForm(BrandType::NAME, $brand), $this->translator->trans('oro.product.brand.form.update.messages.saved'), $request, new BrandHandler($this->form, $request, $this->entityManager), // Il est l\u00e0 ); } A quoi \u00e7a ressemble : <?php namespace Acme\\Bundle\\FooBundle\\Form\\Handler; use Doctrine\\Common\\Persistence\\ObjectManager; use Oro\\Bundle\\FormBundle\\Form\\Handler\\FormHandlerInterface; use Symfony\\Component\\Form\\FormInterface; use Symfony\\Component\\HttpFoundation\\Request; use Oro\\Bundle\\ProductBundle\\Entity\\Brand; class BrandHandler implements FormHandlerInterface { /** * @var FormInterface */ protected $form; /** * @var Request */ protected $request; /** * @var ObjectManager */ protected $manager; /** * @param FormInterface $form * @param Request $request * @param ObjectManager $manager */ public function __construct(FormInterface $form, Request $request, ObjectManager $manager) { $this->form = $form; $this->request = $request; $this->manager = $manager; } /** * {@inheritdoc} */ public function process($data, FormInterface $form, Request $request) { if (!$data instanceof Brand) { throw new \\InvalidArgumentException(\"Si data n'est pas une instance de brand on sort\"); } $form->setData($data); // On set les donn\u00e9es dans le formulaire if (in_array($request->getMethod(), ['POST', 'PUT'])) { $form->submit($request); // On submit le formulaire if ($form->isValid()) { $this->onSuccess($data); return true; } } return false; } /** * \"Success\" form handler * * @param Brand $brand */ protected function onSuccess(Brand $brand) { $this->manager->persist($brand); $this->manager->flush(); } } Concr\u00e8tement tel qu'il est notre handler ne sert a rien. Il fait exactement ce que fait la premi\u00e8re portion de code. Mais il nous perment d'avoir la main sur la mani\u00e8re dont est persist\u00e9e notre entit\u00e9 brand. Le Provider Le provider va permettre d'avoir la main sur la r\u00e9ponse qui \u00eatre renvoy\u00e9e a la vue. protected function update(Brand $brand, Request $request) { return $this->updateHandler->update( $brand, $this->form, $this->translator->trans('oro.product.brand.form.update.messages.saved'), $request, new BrandHandler($this->form, $request, $this->entityManager), new BrandProvider($brand, $this->form, $request) // Il est l\u00e0 ); } On doit implementer FormTemplateDataProviderInterface, et on peut construire notre r\u00e9ponse dans la m\u00e9thode getData() <?php namespace Acme\\Bundle\\FooBundle\\Provider; use Oro\\Bundle\\ProductBundle\\Entity\\Brand; use Oro\\Bundle\\FormBundle\\Provider\\FormTemplateDataProviderInterface; use Symfony\\Component\\Form\\FormInterface; use Symfony\\Component\\HttpFoundation\\Request; class BrandProvider implements FormTemplateDataProviderInterface { /** * @var Brand $entity */ private $entity; /** * @var FormInterface $form */ private $channelRuleGroupType; /** * @var Request $form */ private $request; /** * * @param Brand $entity * @param FormInterface $channelRuleGroupType * @param Request $request */ public function __construct(Brand $entity, FormInterface $channelRuleGroupType, Request $request) { $this->entity = $entity; $this->channelRuleGroupType = $channelRuleGroupType; $this->request = $request; } public function getData($entity, FormInterface $form, Request $request) { return [ 'custom' => 'Je suis un truc dont la vue a besoin', ]; } }","title":"Faire des handlers / providers (update entity)"},{"location":"backend/handler-provider-update/#scenario","text":"J'ai des besoins complexes de persitances d'entit\u00e9es et de r\u00e9ponses \u00e0 renvoyer \u00e0 la vue que le UpdateHandlerFacade ne peut satisfaire","title":"Sc\u00e9nario :"},{"location":"backend/handler-provider-update/#le-cas-simple","text":"Ceci est l'update de Oro/Bundle/ProductBundle/Controller/BrandController. Il fonctionne assez simplement : On passe au update_handler - L'entit\u00e9 ($brand) - Le form - L'objet request - Une cha\u00eene de caract\u00e8re traduite \u00e0 afficher quand la sauvegarde est faite. protected function update(Brand $brand, Request $request) { return $this->get('oro_form.update_handler')->update( $brand, $this->createForm(BrandType::NAME, $brand), $this->get('translator')->trans('oro.product.brand.form.update.messages.saved'), $request, null ); } L'UpdateHandlerFacade s'occupe d'enregistrer la donn\u00e9e et de construire une r\u00e9ponse qui est renvoy\u00e9e a la vue.","title":"Le cas simple"},{"location":"backend/handler-provider-update/#le-cas-plus-complique","text":"En utilisant la m\u00e9thode pr\u00e9cedente, on n'a ni la main sur la mani\u00e8re dont Oro persiste notre entit\u00e9e, ni sur la r\u00e9ponse qu'il va construire et renvoyer \u00e0 la vue.","title":"Le cas plus compliqu\u00e9"},{"location":"backend/handler-provider-update/#le-handler","text":"Le handler permet de d\u00e9l\u00e8guer tout le traitement d'un formulaire. L'utilisation d'un handler \u00e0 nous : protected function update(Brand $brand, Request $request) { return $this->updateHandler->update( $brand, $this->createForm(BrandType::NAME, $brand), $this->translator->trans('oro.product.brand.form.update.messages.saved'), $request, new BrandHandler($this->form, $request, $this->entityManager), // Il est l\u00e0 ); } A quoi \u00e7a ressemble : <?php namespace Acme\\Bundle\\FooBundle\\Form\\Handler; use Doctrine\\Common\\Persistence\\ObjectManager; use Oro\\Bundle\\FormBundle\\Form\\Handler\\FormHandlerInterface; use Symfony\\Component\\Form\\FormInterface; use Symfony\\Component\\HttpFoundation\\Request; use Oro\\Bundle\\ProductBundle\\Entity\\Brand; class BrandHandler implements FormHandlerInterface { /** * @var FormInterface */ protected $form; /** * @var Request */ protected $request; /** * @var ObjectManager */ protected $manager; /** * @param FormInterface $form * @param Request $request * @param ObjectManager $manager */ public function __construct(FormInterface $form, Request $request, ObjectManager $manager) { $this->form = $form; $this->request = $request; $this->manager = $manager; } /** * {@inheritdoc} */ public function process($data, FormInterface $form, Request $request) { if (!$data instanceof Brand) { throw new \\InvalidArgumentException(\"Si data n'est pas une instance de brand on sort\"); } $form->setData($data); // On set les donn\u00e9es dans le formulaire if (in_array($request->getMethod(), ['POST', 'PUT'])) { $form->submit($request); // On submit le formulaire if ($form->isValid()) { $this->onSuccess($data); return true; } } return false; } /** * \"Success\" form handler * * @param Brand $brand */ protected function onSuccess(Brand $brand) { $this->manager->persist($brand); $this->manager->flush(); } } Concr\u00e8tement tel qu'il est notre handler ne sert a rien. Il fait exactement ce que fait la premi\u00e8re portion de code. Mais il nous perment d'avoir la main sur la mani\u00e8re dont est persist\u00e9e notre entit\u00e9 brand.","title":"Le Handler"},{"location":"backend/handler-provider-update/#le-provider","text":"Le provider va permettre d'avoir la main sur la r\u00e9ponse qui \u00eatre renvoy\u00e9e a la vue. protected function update(Brand $brand, Request $request) { return $this->updateHandler->update( $brand, $this->form, $this->translator->trans('oro.product.brand.form.update.messages.saved'), $request, new BrandHandler($this->form, $request, $this->entityManager), new BrandProvider($brand, $this->form, $request) // Il est l\u00e0 ); } On doit implementer FormTemplateDataProviderInterface, et on peut construire notre r\u00e9ponse dans la m\u00e9thode getData() <?php namespace Acme\\Bundle\\FooBundle\\Provider; use Oro\\Bundle\\ProductBundle\\Entity\\Brand; use Oro\\Bundle\\FormBundle\\Provider\\FormTemplateDataProviderInterface; use Symfony\\Component\\Form\\FormInterface; use Symfony\\Component\\HttpFoundation\\Request; class BrandProvider implements FormTemplateDataProviderInterface { /** * @var Brand $entity */ private $entity; /** * @var FormInterface $form */ private $channelRuleGroupType; /** * @var Request $form */ private $request; /** * * @param Brand $entity * @param FormInterface $channelRuleGroupType * @param Request $request */ public function __construct(Brand $entity, FormInterface $channelRuleGroupType, Request $request) { $this->entity = $entity; $this->channelRuleGroupType = $channelRuleGroupType; $this->request = $request; } public function getData($entity, FormInterface $form, Request $request) { return [ 'custom' => 'Je suis un truc dont la vue a besoin', ]; } }","title":"Le Provider"},{"location":"backend/oro-config-select-type/","text":"Utiliser un select type dans la config Oro! Pour utiliser un champ select h\u00e9ritant de OroEntitySelectOrCreateInlineType, on ne peux simplement utiliser des transformers pour convertir un objet en Id pour que l'on puisse enregistrer un id au lieu d'un objet en base.(Sinon vous allez avoir des surprises en prod :) ) Explication Le champ Select vas utiliser la ModelData du formulaire pour la transmettre a l'autocomplete qui utilise un objet. ( Oro/Bundle/ConfigBundle/Form/Handler/ConfigHandler.php pour plus de pr\u00e9cisions). OroEntitySelectOrCreateInlineType utilise lui meme un EntityToIdTransformer pour transformer la donn\u00e9e. Donc il ne faut pas rajouter d'autre DataTransformer sinon vous aurez des erreurs. Il faut donc transformer la donn\u00e9e autre part, mais ou ? Solution Tout d'abord cr\u00e9er un formulaire comme ceci : <?php namespace SliderBundle\\Form\\Type; use Doctrine\\Common\\Persistence\\ObjectRepository; use Oro\\Bundle\\FormBundle\\Form\\Type\\OroEntitySelectOrCreateInlineType; use SliderBundle\\Form\\DataTransformer\\SliderModelTransformer; use SliderBundle\\Form\\DataTransformer\\SliderViewTransformer; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\OptionsResolver\\OptionsResolver; class SliderSelectType extends AbstractType { const NAME = 'kiboko_slider_select'; /** * {@inheritdoc} */ public function configureOptions(OptionsResolver $resolver) { $resolver->setDefaults( [ 'autocomplete_alias' => 'kiboko_slider', 'create_form_route' => 'kiboko_slider_create', 'grid_name' => 'kiboko-slider-grid', 'configs' => [ 'placeholder' => 'kiboko.slider.form.choose', ] ] ); } /** * {@inheritdoc} */ public function getParent() { return OroEntitySelectOrCreateInlineType::class; } /** * {@inheritdoc} */ public function getName() { return $this->getBlockPrefix(); } /** * {@inheritdoc} */ public function getBlockPrefix() { return self::NAME; } } Assurez vous bien d'avoir un search handler: services.yml : ```kiboko.form.autocomplete.slider.search_handler: public: false parent: oro_form.autocomplete.search_handler arguments: - '%kiboko.entity.slider.class%' - [\"name\"] tags: - { name: oro_form.autocomplete.search_handler, alias: kiboko_slider } search.yml : search: SliderBundle\\Entity\\Slider: alias: kiboko_slider title_fields: [name] route: name: kiboko_slider_view parameters: id: id search_template: SliderBundle:Search:result.html.twig fields: - name: name target_type: text target_fields: [name] Dans votre fichier de Configuration dans DependencyInjection votre config doit \u00eatre de type **string** pour stocker l'id de l'entit\u00e9. 'slider' => ['type' => 'string', 'value' => null], et dans votre fichier system_configuration.yml slider_bundle.slider: data_type: string type: SliderBundle\\Form\\Type\\SliderSelectType options: label: kiboko.slider.system_configuration.fields.slider.label tooltip: kiboko.slider.system_configuration.fields.slider.label.tooltip required: true configs: placeholder: 'kiboko.slider.form.choose_slider' result_template_twig: 'SliderBundle:Slider:Autocomplete/result.html.twig' selection_template_twig: 'SliderBundle:Slider:Autocomplete/selection.html.twig' constraints: - NotBlank: ~ A vous de personnalisez vos templates twig a votre sauce :) Bon, jusqu'ici nous avons notre champ select mais ils nous faut la logique de transformation : Pour cela cr\u00e9er une classe SystemConfigListener dans un dossier EventListener, comme ceci : namespace SliderBundle\\EventListener; use Doctrine\\Common\\Persistence\\ManagerRegistry; use Oro\\Bundle\\ConfigBundle\\Config\\ConfigManager; use Oro\\Bundle\\ConfigBundle\\Event\\ConfigSettingsUpdateEvent; use SliderBundle\\DependencyInjection\\SliderExtension; class SystemConfigListener { const SETTING = 'slider'; /* * @var ManagerRegistry / protected $registry; /* * @var string / protected $sliderClass; /* * @param ManagerRegistry $registry * @param string $userClass / public function __construct(ManagerRegistry $registry, $userClass) { $this->registry = $registry; $this->sliderClass = $userClass; } / * @param ConfigSettingsUpdateEvent $event */ public function onFormPreSetData(ConfigSettingsUpdateEvent $event) { $settingsKey = implode(ConfigManager::SECTION_VIEW_SEPARATOR, [SliderExtension::ALIAS, self::SETTING]); $settings = $event->getSettings(); if (is_array($settings) && !empty($settings[$settingsKey]['value']) ) { $settings[$settingsKey]['value'] = $this->registry ->getManagerForClass($this->sliderClass) ->find($this->sliderClass, $settings[$settingsKey]['value']); $event->setSettings($settings); } } / * @param ConfigSettingsUpdateEvent $event */ public function onSettingsSaveBefore(ConfigSettingsUpdateEvent $event) { $settings = $event->getSettings(); if (!array_key_exists('value', $settings)) { return; } if (!is_a($settings['value'], $this->sliderClass)) { return; } /* @var object $owner / $slider = $settings['value']; $settings['value'] = $slider->getId(); $event->setSettings($settings); } } Le but de cette classe et de r\u00e9cup\u00e9rer l'entit\u00e9 en fonction de son id lors du chargement de la page et de transformer cet objet en id lors d'un submit. et du coup pour \u00e7a il faut d\u00e9clarer le service comme ceci ```` kiboko.slider.event_listener.system_config: class: SliderBundle\\EventListener\\SystemConfigListener arguments: - \"@doctrine\" - '%kiboko.entity.slider.class%' tags: - { name: kernel.event_listener, event: oro_config.settings_form_preset, method: onFormPreSetData } - { name: kernel.event_listener, event: oro_config.settings_before_save.slider_bundle.slider, method: onSettingsSaveBefore } ```` Sachant que **slider_bundle** c'est votre alias de votre extension et **slider** votre config sp\u00e9cifique : class SliderExtension extends Extension { const ALIAS = 'slider_bundle'; ```","title":"Champ select en config"},{"location":"backend/oro-config-select-type/#utiliser-un-select-type-dans-la-config-oro","text":"Pour utiliser un champ select h\u00e9ritant de OroEntitySelectOrCreateInlineType, on ne peux simplement utiliser des transformers pour convertir un objet en Id pour que l'on puisse enregistrer un id au lieu d'un objet en base.(Sinon vous allez avoir des surprises en prod :) )","title":"Utiliser un select type dans la config Oro!"},{"location":"backend/oro-config-select-type/#explication","text":"Le champ Select vas utiliser la ModelData du formulaire pour la transmettre a l'autocomplete qui utilise un objet. ( Oro/Bundle/ConfigBundle/Form/Handler/ConfigHandler.php pour plus de pr\u00e9cisions). OroEntitySelectOrCreateInlineType utilise lui meme un EntityToIdTransformer pour transformer la donn\u00e9e. Donc il ne faut pas rajouter d'autre DataTransformer sinon vous aurez des erreurs. Il faut donc transformer la donn\u00e9e autre part, mais ou ?","title":"Explication"},{"location":"backend/oro-config-select-type/#solution","text":"Tout d'abord cr\u00e9er un formulaire comme ceci : <?php namespace SliderBundle\\Form\\Type; use Doctrine\\Common\\Persistence\\ObjectRepository; use Oro\\Bundle\\FormBundle\\Form\\Type\\OroEntitySelectOrCreateInlineType; use SliderBundle\\Form\\DataTransformer\\SliderModelTransformer; use SliderBundle\\Form\\DataTransformer\\SliderViewTransformer; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; use Symfony\\Component\\OptionsResolver\\OptionsResolver; class SliderSelectType extends AbstractType { const NAME = 'kiboko_slider_select'; /** * {@inheritdoc} */ public function configureOptions(OptionsResolver $resolver) { $resolver->setDefaults( [ 'autocomplete_alias' => 'kiboko_slider', 'create_form_route' => 'kiboko_slider_create', 'grid_name' => 'kiboko-slider-grid', 'configs' => [ 'placeholder' => 'kiboko.slider.form.choose', ] ] ); } /** * {@inheritdoc} */ public function getParent() { return OroEntitySelectOrCreateInlineType::class; } /** * {@inheritdoc} */ public function getName() { return $this->getBlockPrefix(); } /** * {@inheritdoc} */ public function getBlockPrefix() { return self::NAME; } } Assurez vous bien d'avoir un search handler: services.yml : ```kiboko.form.autocomplete.slider.search_handler: public: false parent: oro_form.autocomplete.search_handler arguments: - '%kiboko.entity.slider.class%' - [\"name\"] tags: - { name: oro_form.autocomplete.search_handler, alias: kiboko_slider } search.yml : search: SliderBundle\\Entity\\Slider: alias: kiboko_slider title_fields: [name] route: name: kiboko_slider_view parameters: id: id search_template: SliderBundle:Search:result.html.twig fields: - name: name target_type: text target_fields: [name] Dans votre fichier de Configuration dans DependencyInjection votre config doit \u00eatre de type **string** pour stocker l'id de l'entit\u00e9. 'slider' => ['type' => 'string', 'value' => null], et dans votre fichier system_configuration.yml slider_bundle.slider: data_type: string type: SliderBundle\\Form\\Type\\SliderSelectType options: label: kiboko.slider.system_configuration.fields.slider.label tooltip: kiboko.slider.system_configuration.fields.slider.label.tooltip required: true configs: placeholder: 'kiboko.slider.form.choose_slider' result_template_twig: 'SliderBundle:Slider:Autocomplete/result.html.twig' selection_template_twig: 'SliderBundle:Slider:Autocomplete/selection.html.twig' constraints: - NotBlank: ~ A vous de personnalisez vos templates twig a votre sauce :) Bon, jusqu'ici nous avons notre champ select mais ils nous faut la logique de transformation : Pour cela cr\u00e9er une classe SystemConfigListener dans un dossier EventListener, comme ceci : namespace SliderBundle\\EventListener; use Doctrine\\Common\\Persistence\\ManagerRegistry; use Oro\\Bundle\\ConfigBundle\\Config\\ConfigManager; use Oro\\Bundle\\ConfigBundle\\Event\\ConfigSettingsUpdateEvent; use SliderBundle\\DependencyInjection\\SliderExtension; class SystemConfigListener { const SETTING = 'slider'; /* * @var ManagerRegistry / protected $registry; /* * @var string / protected $sliderClass; /* * @param ManagerRegistry $registry * @param string $userClass / public function __construct(ManagerRegistry $registry, $userClass) { $this->registry = $registry; $this->sliderClass = $userClass; } / * @param ConfigSettingsUpdateEvent $event */ public function onFormPreSetData(ConfigSettingsUpdateEvent $event) { $settingsKey = implode(ConfigManager::SECTION_VIEW_SEPARATOR, [SliderExtension::ALIAS, self::SETTING]); $settings = $event->getSettings(); if (is_array($settings) && !empty($settings[$settingsKey]['value']) ) { $settings[$settingsKey]['value'] = $this->registry ->getManagerForClass($this->sliderClass) ->find($this->sliderClass, $settings[$settingsKey]['value']); $event->setSettings($settings); } } / * @param ConfigSettingsUpdateEvent $event */ public function onSettingsSaveBefore(ConfigSettingsUpdateEvent $event) { $settings = $event->getSettings(); if (!array_key_exists('value', $settings)) { return; } if (!is_a($settings['value'], $this->sliderClass)) { return; } /* @var object $owner / $slider = $settings['value']; $settings['value'] = $slider->getId(); $event->setSettings($settings); } } Le but de cette classe et de r\u00e9cup\u00e9rer l'entit\u00e9 en fonction de son id lors du chargement de la page et de transformer cet objet en id lors d'un submit. et du coup pour \u00e7a il faut d\u00e9clarer le service comme ceci ```` kiboko.slider.event_listener.system_config: class: SliderBundle\\EventListener\\SystemConfigListener arguments: - \"@doctrine\" - '%kiboko.entity.slider.class%' tags: - { name: kernel.event_listener, event: oro_config.settings_form_preset, method: onFormPreSetData } - { name: kernel.event_listener, event: oro_config.settings_before_save.slider_bundle.slider, method: onSettingsSaveBefore } ```` Sachant que **slider_bundle** c'est votre alias de votre extension et **slider** votre config sp\u00e9cifique : class SliderExtension extends Extension { const ALIAS = 'slider_bundle'; ```","title":"Solution"},{"location":"backend/pass-param-to-datagrid/","text":"Sc\u00e9nario : Je faire passer un param\u00e8tre \u00e0 ma datagrid Comment cr\u00e9er passer un param\u00e8tre \u00e0 ma datagrid Placez-vous dans votre datagrid : # src/Acme/Bundle/YourBundle/Resources/config/oro/datagrids.yml datagrids: # ... acme-test-grid: # ... source: query: where: and: - test.relation = :param bind_parameters: - param # ... # ... Dans votre twig {# src/Acme/Bundle/YourBundle/Resources/views/Test/test.html.twig #} {% import 'OroDataGridBundle::macros.html.twig' as dataGrid %} <div class=\"widget-content\"> {{ dataGrid.renderGrid('acme-test-grid', {param: yourparam}) }} </div>","title":"Faire passer un param\u00e8tre \u00e0 une datagrid"},{"location":"backend/pass-param-to-datagrid/#scenario","text":"Je faire passer un param\u00e8tre \u00e0 ma datagrid","title":"Sc\u00e9nario :"},{"location":"backend/pass-param-to-datagrid/#comment-creer-passer-un-parametre-a-ma-datagrid","text":"Placez-vous dans votre datagrid : # src/Acme/Bundle/YourBundle/Resources/config/oro/datagrids.yml datagrids: # ... acme-test-grid: # ... source: query: where: and: - test.relation = :param bind_parameters: - param # ... # ... Dans votre twig {# src/Acme/Bundle/YourBundle/Resources/views/Test/test.html.twig #} {% import 'OroDataGridBundle::macros.html.twig' as dataGrid %} <div class=\"widget-content\"> {{ dataGrid.renderGrid('acme-test-grid', {param: yourparam}) }} </div>","title":"Comment cr\u00e9er passer un param\u00e8tre \u00e0 ma datagrid"},{"location":"backend/remove-price-filter/","text":"Remove Price filter and sorter Description To remove Price filter and sorter in frontend_product_search_datagrid it is necessary to create an EventListener to edit the datagrid Services # src/Kiboko/Bundle/FooBundle/Resources/config/services.yml services: kiboko_foo.event_listener.frontend.product_price_datagrid: class: Kiboko\\Bundle\\CorporateProductBundle\\EventListener\\FrontendProductRemovePriceDatagridListener tags: - { name: kernel.event_listener, event: oro_datagrid.datagrid.build.before.frontend-product-search-grid, method: onBuildBefore } Datagrid listener <?php # src/Kiboko/Bundle/FooBundle/EventListener/FrontendProductRemovePriceDatagridListener.php namespace Kiboko\\Bundle\\FooBundle\\EventListener; use Oro\\Bundle\\DataGridBundle\\Event\\BuildBefore; use Oro\\Bundle\\PricingBundle\\EventListener\\FrontendProductPriceDatagridListener; class FrontendProductRemovePriceDatagridListener { /** * {@inheritDoc} */ public function onBuildBefore(BuildBefore $event) { $config = $event->getConfig(); $config->removeSorter(FrontendProductPriceDatagridListener::COLUMN_MINIMAL_PRICE_SORT); $config->removeFilter(FrontendProductPriceDatagridListener::COLUMN_MINIMAL_PRICE); } } Check other methods to customize DataGrid","title":"Remove Price filter and sorter"},{"location":"backend/remove-price-filter/#remove-price-filter-and-sorter","text":"","title":"Remove Price filter and sorter"},{"location":"backend/remove-price-filter/#description","text":"To remove Price filter and sorter in frontend_product_search_datagrid it is necessary to create an EventListener to edit the datagrid","title":"Description"},{"location":"backend/remove-price-filter/#services","text":"# src/Kiboko/Bundle/FooBundle/Resources/config/services.yml services: kiboko_foo.event_listener.frontend.product_price_datagrid: class: Kiboko\\Bundle\\CorporateProductBundle\\EventListener\\FrontendProductRemovePriceDatagridListener tags: - { name: kernel.event_listener, event: oro_datagrid.datagrid.build.before.frontend-product-search-grid, method: onBuildBefore }","title":"Services"},{"location":"backend/remove-price-filter/#datagrid-listener","text":"<?php # src/Kiboko/Bundle/FooBundle/EventListener/FrontendProductRemovePriceDatagridListener.php namespace Kiboko\\Bundle\\FooBundle\\EventListener; use Oro\\Bundle\\DataGridBundle\\Event\\BuildBefore; use Oro\\Bundle\\PricingBundle\\EventListener\\FrontendProductPriceDatagridListener; class FrontendProductRemovePriceDatagridListener { /** * {@inheritDoc} */ public function onBuildBefore(BuildBefore $event) { $config = $event->getConfig(); $config->removeSorter(FrontendProductPriceDatagridListener::COLUMN_MINIMAL_PRICE_SORT); $config->removeFilter(FrontendProductPriceDatagridListener::COLUMN_MINIMAL_PRICE); } } Check other methods to customize DataGrid","title":"Datagrid listener"},{"location":"command/oro1/","text":"Useful command with Oro 1.x Lancer la Consume-list app/console oro:message-queue:consume ``` > Avec plus ou moins d'informations ```bash app/console oro:message-queue:consume -v app/console oro:message-queue:consume -vv app/console oro:message-queue:consume -vvv ``` > Effacer le cache ```bash rm -rf app/cache/* Mot de passe oubli\u00e9 app/console oro:user:update nomUser --user-password=root G\u00e9nerer les assets app/console oro:asset:install && app/console assetic:dump Faire un symlink (ne marche pas en cas de cr\u00e9ation de fichier) app/console oro:asset:install --symlink Lancer les migrations de schema app/console oro:migration:load Lancer les migrations de data app/console oro:migration:data:load Creer un token d'acc\u00e8s limit\u00e9 dans le temps app/console oro:user:impersonate user R\u00e9cuperer/G\u00e9nerer Traductions app/console oro:translation:load app/console oro:translation:dump G\u00e9nerer les routes JS (Api/Components) app/console fos:js-routing:dump --target web/js/routes.js","title":"Oro 1.x"},{"location":"command/oro1/#useful-command-with-oro-1x","text":"Lancer la Consume-list app/console oro:message-queue:consume ``` > Avec plus ou moins d'informations ```bash app/console oro:message-queue:consume -v app/console oro:message-queue:consume -vv app/console oro:message-queue:consume -vvv ``` > Effacer le cache ```bash rm -rf app/cache/* Mot de passe oubli\u00e9 app/console oro:user:update nomUser --user-password=root G\u00e9nerer les assets app/console oro:asset:install && app/console assetic:dump Faire un symlink (ne marche pas en cas de cr\u00e9ation de fichier) app/console oro:asset:install --symlink Lancer les migrations de schema app/console oro:migration:load Lancer les migrations de data app/console oro:migration:data:load Creer un token d'acc\u00e8s limit\u00e9 dans le temps app/console oro:user:impersonate user R\u00e9cuperer/G\u00e9nerer Traductions app/console oro:translation:load app/console oro:translation:dump G\u00e9nerer les routes JS (Api/Components) app/console fos:js-routing:dump --target web/js/routes.js","title":"Useful command with Oro 1.x"},{"location":"command/oro3/","text":"Useful command with Oro 3.x Generic Install composer install --prefer-dist --no-dev bin/console oro:install --timeout=0 Start message queue consume bin/console oro:message-queue:consume with less or more informations bin/console oro:message-queue:consume -v bin/console oro:message-queue:consume -vv bin/console oro:message-queue:consume -vvv Remove cache rm -rf var/cache/* Indexation Search bin/console oro:search:index bin/console oro:search:reindex Website bin/console oro:website-search:reindex bin/console oro:website-search:reindex --website-id=2 Update entities bin/console oro:entity-extend:cache:check Makes sure that extended entity configs are ready to be processed by other commands. This is an internal command. Please do not run it manually. bin/console oro:entity-extend:cache:clear Clears extended entity cache. bin/console oro:entity-extend:cache:warmup Warms up extended entity cache. bin/console oro:entity-extend:migration:update-config Updates extended entities configuration during a database structure migration process. This is an internal command. Please do not run it manually. bin/console oro:entity-extend:update-config Prepare entity config bin/console oro:entity-extend:update-schema Synchronize extended and custom entities metadata with a database schema Assets Install assets 3.0 (with assetic) bin/console oro:asset:install && bin/console assetic:dump bin/console oro:assets:install -e dev && bin/console assetic:dump -e dev 3.1 (with webpack) bin/console asset:install && bin/console oro:asset:build bin/console asset:install --env=dev && bin/console oro:asset:build --env=dev with symlink (without new file creation) bin/console oro:asset:install --symlink Migrations Schema migrations bin/console oro:migration:load Data migrations bin/console oro:migration:data:load Data migrations dump bin/console oro:migration:dump more : https://github.com/oroinc/platform/tree/master/src/Oro/Bundle/MigrationBundle Users Password changing bin/console oro:user:update nomUser --user-password=root Create a limited access token over time bin/console oro:user:impersonate user ElasticSearch En cas d'erreur d'indexation : bin/console oro:website-elasticsearch:create-website-indexes Others Translations bin/console oro:translation:load bin/console oro:translation:dump bin/console oro:translation:dump && bin/console oro:localization:dump Load with parameters : bin/console oro:translation:load --languages=en --languages=fr --rebuild-cache D\u00e9tails : https://github.com/oroinc/platform/blob/master/src/Oro/Bundle/TranslationBundle/Resources/doc/reference/commands.md Generate JS routing (Api/Components) bin/console fos:js-routing:dump --target web/js/routes.js Worflows & Processes bin/console oro:workflow:definitions:load bin/console oro:process:configuration:load And more If you need Bruce's power : https://github.com/kiboko-labs/KibokoArmageddonBundle","title":"Oro 3.x"},{"location":"command/oro3/#useful-command-with-oro-3x","text":"","title":"Useful command with Oro 3.x"},{"location":"command/oro3/#generic","text":"Install composer install --prefer-dist --no-dev bin/console oro:install --timeout=0 Start message queue consume bin/console oro:message-queue:consume with less or more informations bin/console oro:message-queue:consume -v bin/console oro:message-queue:consume -vv bin/console oro:message-queue:consume -vvv Remove cache rm -rf var/cache/*","title":"Generic"},{"location":"command/oro3/#indexation","text":"Search bin/console oro:search:index bin/console oro:search:reindex Website bin/console oro:website-search:reindex bin/console oro:website-search:reindex --website-id=2","title":"Indexation"},{"location":"command/oro3/#update-entities","text":"bin/console oro:entity-extend:cache:check Makes sure that extended entity configs are ready to be processed by other commands. This is an internal command. Please do not run it manually. bin/console oro:entity-extend:cache:clear Clears extended entity cache. bin/console oro:entity-extend:cache:warmup Warms up extended entity cache. bin/console oro:entity-extend:migration:update-config Updates extended entities configuration during a database structure migration process. This is an internal command. Please do not run it manually. bin/console oro:entity-extend:update-config Prepare entity config bin/console oro:entity-extend:update-schema Synchronize extended and custom entities metadata with a database schema","title":"Update entities"},{"location":"command/oro3/#assets","text":"Install assets 3.0 (with assetic) bin/console oro:asset:install && bin/console assetic:dump bin/console oro:assets:install -e dev && bin/console assetic:dump -e dev 3.1 (with webpack) bin/console asset:install && bin/console oro:asset:build bin/console asset:install --env=dev && bin/console oro:asset:build --env=dev with symlink (without new file creation) bin/console oro:asset:install --symlink","title":"Assets"},{"location":"command/oro3/#migrations","text":"Schema migrations bin/console oro:migration:load Data migrations bin/console oro:migration:data:load Data migrations dump bin/console oro:migration:dump more : https://github.com/oroinc/platform/tree/master/src/Oro/Bundle/MigrationBundle","title":"Migrations"},{"location":"command/oro3/#users","text":"Password changing bin/console oro:user:update nomUser --user-password=root Create a limited access token over time bin/console oro:user:impersonate user","title":"Users"},{"location":"command/oro3/#elasticsearch","text":"En cas d'erreur d'indexation : bin/console oro:website-elasticsearch:create-website-indexes","title":"ElasticSearch"},{"location":"command/oro3/#others","text":"Translations bin/console oro:translation:load bin/console oro:translation:dump bin/console oro:translation:dump && bin/console oro:localization:dump Load with parameters : bin/console oro:translation:load --languages=en --languages=fr --rebuild-cache D\u00e9tails : https://github.com/oroinc/platform/blob/master/src/Oro/Bundle/TranslationBundle/Resources/doc/reference/commands.md Generate JS routing (Api/Components) bin/console fos:js-routing:dump --target web/js/routes.js Worflows & Processes bin/console oro:workflow:definitions:load bin/console oro:process:configuration:load","title":"Others"},{"location":"command/oro3/#and-more","text":"If you need Bruce's power : https://github.com/kiboko-labs/KibokoArmageddonBundle","title":"And more"},{"location":"docker/clean-vm/","text":"Nettoyage de la VM Documentation https://docs.docker.com/config/pruning/ Processus Pour lib\u00e9rer de l'espace sur VM, on peut lancer plusieurs commandes pour supprimer les images et les volumes qui sont non utilis\u00e9s : docker image prune docker volume prune Attention \u00e0 ne pas supprimer tous ses containers","title":"Nettoyer sa VM"},{"location":"docker/clean-vm/#nettoyage-de-la-vm","text":"","title":"Nettoyage de la VM"},{"location":"docker/clean-vm/#documentation","text":"https://docs.docker.com/config/pruning/","title":"Documentation"},{"location":"docker/clean-vm/#processus","text":"Pour lib\u00e9rer de l'espace sur VM, on peut lancer plusieurs commandes pour supprimer les images et les volumes qui sont non utilis\u00e9s : docker image prune docker volume prune Attention \u00e0 ne pas supprimer tous ses containers","title":"Processus"},{"location":"docker/dump-sql-docker/","text":"Manipuler des dumps avec docker On a un dump sql que l'on veut monter sur notre container sql Imaginons que nous avons notre dump.sql sur notre host. On peut copier un fichier du local au container : docker cp dump.sql mycontainer:/tmp/dump.sql Le fichier dump.sql est maintenant sur le container, dans le dossier /tmp/ L'inverse est possible aussi (copier du container au host: docker cp mycontainer:/foo.txt /chemin/foo.txt On lance le batch un bash du container mysql docker exec -ti le-container_mysql bash `````` On lance la commande avec l'option -v ( pour voir le dump avec du \"verbose\" ): `mysql` : ```bash mysql -v \u2014batch -h{host} -u{user} -p nom-de-la-base-de-donn\u00e9e < /tmp/bdd.sql `````` `postgresql` : ```bash psql -v -h{host} -U{user} -W -dnom-de-la-base-de-donn\u00e9e < /tmp/bdd.sql `````` Short one :) ## Backup ```bash docker exec CONTAINER /usr/bin/mysqldump -u root --password=root DATABASE > backup.sql Restore cat backup.sql | docker exec -i CONTAINER /usr/bin/mysql -u root --password=root DATABASE","title":"Maninipuler des dumps.sql avec Docker"},{"location":"docker/dump-sql-docker/#manipuler-des-dumps-avec-docker","text":"On a un dump sql que l'on veut monter sur notre container sql Imaginons que nous avons notre dump.sql sur notre host. On peut copier un fichier du local au container : docker cp dump.sql mycontainer:/tmp/dump.sql Le fichier dump.sql est maintenant sur le container, dans le dossier /tmp/ L'inverse est possible aussi (copier du container au host: docker cp mycontainer:/foo.txt /chemin/foo.txt On lance le batch un bash du container mysql docker exec -ti le-container_mysql bash `````` On lance la commande avec l'option -v ( pour voir le dump avec du \"verbose\" ): `mysql` : ```bash mysql -v \u2014batch -h{host} -u{user} -p nom-de-la-base-de-donn\u00e9e < /tmp/bdd.sql `````` `postgresql` : ```bash psql -v -h{host} -U{user} -W -dnom-de-la-base-de-donn\u00e9e < /tmp/bdd.sql `````` Short one :) ## Backup ```bash docker exec CONTAINER /usr/bin/mysqldump -u root --password=root DATABASE > backup.sql","title":"Manipuler des dumps avec docker"},{"location":"docker/dump-sql-docker/#restore","text":"cat backup.sql | docker exec -i CONTAINER /usr/bin/mysql -u root --password=root DATABASE","title":"Restore"},{"location":"docker/use-cache/","text":"Sc\u00e9nario : Ma stack docker rame parce que je suis sur MacOS Pourquoi? Contrairement \u00e0 Linux, sur Mac et Windows, Docker va lancer une machine virtuelle et installer tout ce qui l'a besoin dessus. C'est le transfert entre la VM et l'host qui rend Docker si lent sur les OS autres que Linux. Pour pallier \u00e0 \u00e7a on peut utiliser un syst\u00e8me de cache qui s'av\u00e8re tr\u00e8s rentable Les trois type de cache : delegated : Docker > Local , plus rapide en \u00e9criture cached : Local > Docker , plus rapide en lecture consistent : Local = Docker, valeur par d\u00e9fault Comment le mettre en place : Exemple du delegated : cli: build: context: .docker/php@7.1/cli user: docker:docker volumes: - ./.docker/php@7.1/cli/config/memory.ini:/usr/local/etc/php/conf.d/memory.ini:ro - ./:/var/www/html On va rajouter cette ligne dans nos volumes : cli: build: context: .docker/php@7.1/cli user: docker:docker volumes: - ./.docker/php@7.1/cli/config/memory.ini:/usr/local/etc/php/conf.d/memory.ini:ro - ./:/var/www/html - ./:/var/www/html:delegated Exemple du cached : http: image: nginx:alpine volumes: - ./:/var/www/html restart: on-failure ports: - 8963:80 Meme logique, on rajoute une ligne : http: image: nginx:alpine volumes: - ./:/var/www/html - ./:/var/www/html:cached restart: on-failure ports: - 8963:80","title":"Utiliser le cache Docker"},{"location":"docker/use-cache/#scenario","text":"Ma stack docker rame parce que je suis sur MacOS","title":"Sc\u00e9nario :"},{"location":"docker/use-cache/#pourquoi","text":"Contrairement \u00e0 Linux, sur Mac et Windows, Docker va lancer une machine virtuelle et installer tout ce qui l'a besoin dessus. C'est le transfert entre la VM et l'host qui rend Docker si lent sur les OS autres que Linux. Pour pallier \u00e0 \u00e7a on peut utiliser un syst\u00e8me de cache qui s'av\u00e8re tr\u00e8s rentable","title":"Pourquoi?"},{"location":"docker/use-cache/#les-trois-type-de-cache","text":"delegated : Docker > Local , plus rapide en \u00e9criture cached : Local > Docker , plus rapide en lecture consistent : Local = Docker, valeur par d\u00e9fault Comment le mettre en place :","title":"Les trois type de cache :"},{"location":"docker/use-cache/#exemple-du-delegated","text":"cli: build: context: .docker/php@7.1/cli user: docker:docker volumes: - ./.docker/php@7.1/cli/config/memory.ini:/usr/local/etc/php/conf.d/memory.ini:ro - ./:/var/www/html On va rajouter cette ligne dans nos volumes : cli: build: context: .docker/php@7.1/cli user: docker:docker volumes: - ./.docker/php@7.1/cli/config/memory.ini:/usr/local/etc/php/conf.d/memory.ini:ro - ./:/var/www/html - ./:/var/www/html:delegated","title":"Exemple du delegated :"},{"location":"docker/use-cache/#exemple-du-cached","text":"http: image: nginx:alpine volumes: - ./:/var/www/html restart: on-failure ports: - 8963:80 Meme logique, on rajoute une ligne : http: image: nginx:alpine volumes: - ./:/var/www/html - ./:/var/www/html:cached restart: on-failure ports: - 8963:80","title":"Exemple du cached :"},{"location":"environment/avoir-xdebug-a-la-demande/","text":"Sc\u00e9nario : Je veux avoir Xdebug activ\u00e9 que pour certaine commandes Pr\u00e9requis : Avoir installer Xdebug Explication : On va faire en sorte d'avoir l'extension Xdebug activ\u00e9e \u00e0 la demande Solution Partons du principe que vous avez la config de xdebug dans votre fichier /usr/local/etc/php/7.2/php.ini`` comme ceci : ;zend_extension=\"/usr/local/Cellar/php@7.2/7.2.15/pecl/20170718/xdebug.so\" xdebug.remote_enable=1 xdebug.remote_host=localhost xdebug.remote_port=9001 xdebug.remote_log=\"xdebug.log\" xdebug.idekey=PHPSTORM xdebug.remote_autostart=1 On duplique ce fichier dans le dossier en renommant la copie php.iniv2 Dans cette copie on d\u00e9commente la ligne zend_extension en enlevant le point-virgule On \u00e9dite le fichier des alias, dans mon cas : nano ~/.bash_profile On ajoute un alias comme ceci : alias phpx=\"php -c /usr/local/etc/php/7.2/php.iniv2\" Et on recharge notre fichier d'alias : source ~/.bash_profile Et voila !!! : ```julien@MBP-de-Julien:~/PhpstormProjects/orocommerce-cheatsheet$ php -v PHP 7.2.15 (cli) (built: Mar 12 2019 09:36:43) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.15, Copyright (c) 1999-2018, by Zend Technologies julien@MBP-de-Julien:~/PhpstormProjects/orocommerce-cheatsheet$ phpx -v PHP 7.2.15 (cli) (built: Mar 12 2019 09:36:43) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Xdebug v2.7.0, Copyright (c) 2002-2019, by Derick Rethans with Zend OPcache v7.2.15, Copyright (c) 1999-2018, by Zend Technologies `` - Petit alias bien pratique pour les utilisateurs du framework Symfony/Oro ... : alias sfx=\"php -c /usr/local/etc/php/7.2/php.iniv2 bin/console\"`","title":"Activer XDebug \u00e0 la demande"},{"location":"environment/avoir-xdebug-a-la-demande/#scenario","text":"Je veux avoir Xdebug activ\u00e9 que pour certaine commandes","title":"Sc\u00e9nario :"},{"location":"environment/avoir-xdebug-a-la-demande/#prerequis","text":"Avoir installer Xdebug","title":"Pr\u00e9requis :"},{"location":"environment/avoir-xdebug-a-la-demande/#explication","text":"On va faire en sorte d'avoir l'extension Xdebug activ\u00e9e \u00e0 la demande","title":"Explication :"},{"location":"environment/avoir-xdebug-a-la-demande/#solution","text":"Partons du principe que vous avez la config de xdebug dans votre fichier /usr/local/etc/php/7.2/php.ini`` comme ceci : ;zend_extension=\"/usr/local/Cellar/php@7.2/7.2.15/pecl/20170718/xdebug.so\" xdebug.remote_enable=1 xdebug.remote_host=localhost xdebug.remote_port=9001 xdebug.remote_log=\"xdebug.log\" xdebug.idekey=PHPSTORM xdebug.remote_autostart=1 On duplique ce fichier dans le dossier en renommant la copie php.iniv2 Dans cette copie on d\u00e9commente la ligne zend_extension en enlevant le point-virgule On \u00e9dite le fichier des alias, dans mon cas : nano ~/.bash_profile On ajoute un alias comme ceci : alias phpx=\"php -c /usr/local/etc/php/7.2/php.iniv2\" Et on recharge notre fichier d'alias : source ~/.bash_profile Et voila !!! : ```julien@MBP-de-Julien:~/PhpstormProjects/orocommerce-cheatsheet$ php -v PHP 7.2.15 (cli) (built: Mar 12 2019 09:36:43) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.15, Copyright (c) 1999-2018, by Zend Technologies julien@MBP-de-Julien:~/PhpstormProjects/orocommerce-cheatsheet$ phpx -v PHP 7.2.15 (cli) (built: Mar 12 2019 09:36:43) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Xdebug v2.7.0, Copyright (c) 2002-2019, by Derick Rethans with Zend OPcache v7.2.15, Copyright (c) 1999-2018, by Zend Technologies `` - Petit alias bien pratique pour les utilisateurs du framework Symfony/Oro ... : alias sfx=\"php -c /usr/local/etc/php/7.2/php.iniv2 bin/console\"`","title":"Solution"},{"location":"environment/composer-tips/","text":"Compose tips https://getcomposer.org/doc/ Install composer install composer install --prefer-dist --no-dev Require Add new component : composer require knplabs/gaufrette If the package is not on https://packagist.org/, simply add repository in json file like this : (...) 'repositories\": { friendsoforo/oro-slider-bundle\": { \"type\": \"vcs\", \"url\": \"git@github.com:FriendsOfOro/OroSliderBundle.git\" } (...) And after you can execute this: composer require friendsoforo/oro-slider-bundle Specific requirement Specific branch : composer require friendsoforo/oro-slider-bundle:dev-staging Specific commit : composer require friendsoforo/oro-slider-bundle:dev-master#d7c1fd6b46e1679835ce4167042847a2fc7c7643 Update Update all components composer update /!\\ always in local Update one component: composer update knplabs/gaufrette:dev-master","title":"Utilisation de composer"},{"location":"environment/composer-tips/#compose-tips","text":"https://getcomposer.org/doc/","title":"Compose tips"},{"location":"environment/composer-tips/#install","text":"composer install composer install --prefer-dist --no-dev","title":"Install"},{"location":"environment/composer-tips/#require","text":"Add new component : composer require knplabs/gaufrette If the package is not on https://packagist.org/, simply add repository in json file like this : (...) 'repositories\": { friendsoforo/oro-slider-bundle\": { \"type\": \"vcs\", \"url\": \"git@github.com:FriendsOfOro/OroSliderBundle.git\" } (...) And after you can execute this: composer require friendsoforo/oro-slider-bundle","title":"Require"},{"location":"environment/composer-tips/#specific-requirement","text":"Specific branch : composer require friendsoforo/oro-slider-bundle:dev-staging Specific commit : composer require friendsoforo/oro-slider-bundle:dev-master#d7c1fd6b46e1679835ce4167042847a2fc7c7643","title":"Specific requirement"},{"location":"environment/composer-tips/#update","text":"Update all components composer update /!\\ always in local Update one component: composer update knplabs/gaufrette:dev-master","title":"Update"},{"location":"environment/installer-rabbitmq-brew/","text":"Sc\u00e9nario : Je veux installer RabbitMQ sur mon poste Comment installer RabbitMQ Ouvrez un terminal: brew install rabbitmq Les excutables sont install\u00e9s ici : /usr/local/sbin export PATH=$PATH:/usr/local/sbin Pour le lancer brew services start rabbitmq Ou rabbitmq-server Le panel d'administatrion est disponible par d\u00e9fault a cette adresse http://localhost:15672 Pour Couper / Relancer le server rabbitmqctl stop_app rabbitmqctl start_app On a besoin de ce plugin, qui n'est pas install\u00e9 par d\u00e9fault : rabbitmq_delayed_message _exchange On le t\u00e9lecharge et on le met au bon endroit wget https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip && unzip rabbitmq_delayed_message_exchange-20171215-3.6.x.zip -d {L'endroit ou est installer RabbitMQ}/plugins && rm rabbitmq_delayed_message_exchange-20171215-3.6.x.zip Pour savoir ou le mettre il faut trouver ou est install\u00e9 rabbitmq : brew info rabbitmq Vous aurez un truc semblable \u00e0 \u00e7a : rabbitmq: stable 3.7.9 Messaging broker https://www.rabbitmq.com /usr/local/Cellar/rabbitmq/3.7.9 (235 files, 13.5MB) * Built from source on 2018-12-28 at 09:46:16 From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/rabbitmq.rb ==> Dependencies Required: erlang \u2714 ==> Caveats Management Plugin enabled by default at http://localhost:15672 Bash completion has been installed to: /usr/local/etc/bash_completion.d To have launchd start rabbitmq now and restart at login: brew services start rabbitmq Or, if you don't want/need a background service you can just run: rabbitmq-server ==> Analytics install: 9,589 (30 days), 33,961 (90 days), 139,298 (365 days) install_on_request: 9,084 (30 days), 31,408 (90 days), 123,830 (365 days) build_error: 0 (30 days) Il est donc visiblement install\u00e9 ici : /usr/local/Cellar/rabbitmq/3.7.9 Ducoup \u00e7a donne \u00e7a : wget https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip && unzip rabbitmq_delayed_message_exchange-20171215-3.6.x.zip -d /usr/local/Cellar/rabbitmq/3.7.9/plugins && rm rabbitmq_delayed_message_exchange-20171215-3.6.x.zip Le plugin est install\u00e9, il faut maintenant l'activer : rabbitmq-plugins enable --offline rabbitmq_delayed_message_exchange Les commandes qui peuvent aider : Fonction Commands Activer un plugin bash rabbitmq-plugins enable nomDuPlugin D\u00e9sactiver un plugin bash rabbitmq-plugins disable nomDuPlugin Lister les plugins bash rabbitmq-plugins list -e Un fois que tout est bon on passe \u00e0 la config : # app/config/config.yml oro_message_queue: transport: default: '%message_queue_transport%' '%message_queue_transport%': '%message_queue_transport_config%' client: ~ Les parem\u00e8tres correspondants : # app/config/parameters.yml message_queue_transport: 'amqp' message_queue_transport_config: { host: 'localhost', port: '5672', user: 'guest', password: 'guest', vhost: '/' On efface le cache et tout devrait fonctionner","title":"Installer RabbitMQ avec Brew sur MacOS"},{"location":"environment/installer-rabbitmq-brew/#scenario","text":"Je veux installer RabbitMQ sur mon poste","title":"Sc\u00e9nario :"},{"location":"environment/installer-rabbitmq-brew/#comment-installer-rabbitmq","text":"Ouvrez un terminal: brew install rabbitmq Les excutables sont install\u00e9s ici : /usr/local/sbin export PATH=$PATH:/usr/local/sbin Pour le lancer brew services start rabbitmq Ou rabbitmq-server Le panel d'administatrion est disponible par d\u00e9fault a cette adresse http://localhost:15672 Pour Couper / Relancer le server rabbitmqctl stop_app rabbitmqctl start_app On a besoin de ce plugin, qui n'est pas install\u00e9 par d\u00e9fault : rabbitmq_delayed_message _exchange On le t\u00e9lecharge et on le met au bon endroit wget https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip && unzip rabbitmq_delayed_message_exchange-20171215-3.6.x.zip -d {L'endroit ou est installer RabbitMQ}/plugins && rm rabbitmq_delayed_message_exchange-20171215-3.6.x.zip Pour savoir ou le mettre il faut trouver ou est install\u00e9 rabbitmq : brew info rabbitmq Vous aurez un truc semblable \u00e0 \u00e7a : rabbitmq: stable 3.7.9 Messaging broker https://www.rabbitmq.com /usr/local/Cellar/rabbitmq/3.7.9 (235 files, 13.5MB) * Built from source on 2018-12-28 at 09:46:16 From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/rabbitmq.rb ==> Dependencies Required: erlang \u2714 ==> Caveats Management Plugin enabled by default at http://localhost:15672 Bash completion has been installed to: /usr/local/etc/bash_completion.d To have launchd start rabbitmq now and restart at login: brew services start rabbitmq Or, if you don't want/need a background service you can just run: rabbitmq-server ==> Analytics install: 9,589 (30 days), 33,961 (90 days), 139,298 (365 days) install_on_request: 9,084 (30 days), 31,408 (90 days), 123,830 (365 days) build_error: 0 (30 days) Il est donc visiblement install\u00e9 ici : /usr/local/Cellar/rabbitmq/3.7.9 Ducoup \u00e7a donne \u00e7a : wget https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip && unzip rabbitmq_delayed_message_exchange-20171215-3.6.x.zip -d /usr/local/Cellar/rabbitmq/3.7.9/plugins && rm rabbitmq_delayed_message_exchange-20171215-3.6.x.zip Le plugin est install\u00e9, il faut maintenant l'activer : rabbitmq-plugins enable --offline rabbitmq_delayed_message_exchange Les commandes qui peuvent aider : Fonction Commands Activer un plugin bash rabbitmq-plugins enable nomDuPlugin D\u00e9sactiver un plugin bash rabbitmq-plugins disable nomDuPlugin Lister les plugins bash rabbitmq-plugins list -e Un fois que tout est bon on passe \u00e0 la config : # app/config/config.yml oro_message_queue: transport: default: '%message_queue_transport%' '%message_queue_transport%': '%message_queue_transport_config%' client: ~ Les parem\u00e8tres correspondants : # app/config/parameters.yml message_queue_transport: 'amqp' message_queue_transport_config: { host: 'localhost', port: '5672', user: 'guest', password: 'guest', vhost: '/' On efface le cache et tout devrait fonctionner","title":"Comment installer RabbitMQ"},{"location":"environment/installer-xdebug-php71/","text":"Sc\u00e9nario : Je veux installer Xdebug pour php7.1 sur MacOs pour d\u00e9bugger du ORO Installer et configurer Xdebug Placez-vous dans un terminal La m\u00e9thode la plus propre est d'ajouter ce repository, Il va nous permettre d'avoir facilement acc\u00e8s \u00e0 toutes les extensions dont on a besoin brew tap kyslik/homebrew-php On cherche celles pour notre version (php7.1) brew search php71 Vous aurez un truc qui ressemble \u00e0 \u00e7a : kyslik/php/php71-amqp kyslik/php/php71-apcu kyslik/php/php71-amqp kyslik/php/php71-intl kyslik/php/php71-apcu-bc kyslik/php/php71-mcrypt kyslik/php/php71-xdebug kyslik/php/php71-mongodb Dans l'imm\u00e9diat on a besoin que de xdebug, on l'installe : brew install kyslik/php/php71-xdebug On v\u00e9rifie : php -v Vous devriez avoir Xdebug qui est apparu : PHP 7.1.14 (cli) (built: Feb 2 2018 08:42:59) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies with Xdebug v2.6.0, Copyright (c) 2002-2018, by Derick Rethans with Zend OPcache v7.1.14, Copyright (c) 1999-2018, by Zend Technologies HomeBrew a du g\u00e9nerer un .ini pour configurer xdebug : php --ini Configuration File (php.ini) Path: /usr/local/etc/php/7.1 Loaded Configuration File: /usr/local/etc/php/7.1/php.ini Scan for additional .ini files in: /usr/local/etc/php/7.1/conf.d Additional .ini files parsed: /usr/local/etc/php/7.1/conf.d/ext-intl.ini, /usr/local/etc/php/7.1/conf.d/ext-mcrypt.ini, /usr/local/etc/php/7.1/conf.d/ext-opcache.ini, /usr/local/etc/php/7.1/conf.d/ext-xdebug.ini On l'ouvre : vim /usr/local/etc/php/7.1/conf.d/ext-xdebug.ini Copiez-collez cette config : [xdebug] zend_extension=\"/usr/local/opt/php71-xdebug/xdebug.so\" xdebug.remote_enable=1 xdebug.remote_host= 127.0.0.1 xdebug.remote_port=9000 xdebug.remote_log =\"/usr/local/etc/php/7.1/conf.d/ext-xdebug.log\" xdebug.idekey = PHPSTORM zend_extension : Chemin de l'extension (automatique) xdebug.remote_host : Le serveur que vous voulez \u00e9couter xdebug.remote_port : Le port que va utiliser xdebug, v\u00e9rifiez bien qu'il n'est pas utilis\u00e9 xdebug.remote_log : On peut logger les erreurs, tr\u00e8s pratique pour d\u00e9bugger, vous pouvez mettre le ficher que vous voulez. Configurer PHPStorm On va dans Pr\u00e9ference > Language & Framework > PHP Dans Cli Interpreter, on choisi notre php 7.1, et on clique sur les \"...\" On oublie pas de mettre le chemin de l'extension (La valeur de zend_extension) On va dans Run > Edit Configuration > Le bouton + > PHP Web PAGE On cr\u00e9er le serveur Host : Vous mettez l'IP que vous utilisez avec le app/console server:start Port : Pareil On oublie pas de s\u00e9lectionner Xdebug Mapping : Si vous n'en mettez pas, et que vous avez une erreur sans, mettez le m\u00eame chemin \u00e0 droite qu'\u00e0 gauche. On va dans Pr\u00e9ference > Language & Framework > PHP > Debug Tout devrait \u00eatre bon, on va dans Run > Debug , on choisi notre PHP Web Page, et voil\u00e0 !","title":"Installer Xdebug pour php 7.1 sur MacOS"},{"location":"environment/installer-xdebug-php71/#scenario","text":"Je veux installer Xdebug pour php7.1 sur MacOs pour d\u00e9bugger du ORO","title":"Sc\u00e9nario :"},{"location":"environment/installer-xdebug-php71/#installer-et-configurer-xdebug","text":"Placez-vous dans un terminal La m\u00e9thode la plus propre est d'ajouter ce repository, Il va nous permettre d'avoir facilement acc\u00e8s \u00e0 toutes les extensions dont on a besoin brew tap kyslik/homebrew-php On cherche celles pour notre version (php7.1) brew search php71 Vous aurez un truc qui ressemble \u00e0 \u00e7a : kyslik/php/php71-amqp kyslik/php/php71-apcu kyslik/php/php71-amqp kyslik/php/php71-intl kyslik/php/php71-apcu-bc kyslik/php/php71-mcrypt kyslik/php/php71-xdebug kyslik/php/php71-mongodb Dans l'imm\u00e9diat on a besoin que de xdebug, on l'installe : brew install kyslik/php/php71-xdebug On v\u00e9rifie : php -v Vous devriez avoir Xdebug qui est apparu : PHP 7.1.14 (cli) (built: Feb 2 2018 08:42:59) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies with Xdebug v2.6.0, Copyright (c) 2002-2018, by Derick Rethans with Zend OPcache v7.1.14, Copyright (c) 1999-2018, by Zend Technologies HomeBrew a du g\u00e9nerer un .ini pour configurer xdebug : php --ini Configuration File (php.ini) Path: /usr/local/etc/php/7.1 Loaded Configuration File: /usr/local/etc/php/7.1/php.ini Scan for additional .ini files in: /usr/local/etc/php/7.1/conf.d Additional .ini files parsed: /usr/local/etc/php/7.1/conf.d/ext-intl.ini, /usr/local/etc/php/7.1/conf.d/ext-mcrypt.ini, /usr/local/etc/php/7.1/conf.d/ext-opcache.ini, /usr/local/etc/php/7.1/conf.d/ext-xdebug.ini On l'ouvre : vim /usr/local/etc/php/7.1/conf.d/ext-xdebug.ini Copiez-collez cette config : [xdebug] zend_extension=\"/usr/local/opt/php71-xdebug/xdebug.so\" xdebug.remote_enable=1 xdebug.remote_host= 127.0.0.1 xdebug.remote_port=9000 xdebug.remote_log =\"/usr/local/etc/php/7.1/conf.d/ext-xdebug.log\" xdebug.idekey = PHPSTORM zend_extension : Chemin de l'extension (automatique) xdebug.remote_host : Le serveur que vous voulez \u00e9couter xdebug.remote_port : Le port que va utiliser xdebug, v\u00e9rifiez bien qu'il n'est pas utilis\u00e9 xdebug.remote_log : On peut logger les erreurs, tr\u00e8s pratique pour d\u00e9bugger, vous pouvez mettre le ficher que vous voulez.","title":"Installer et configurer Xdebug"},{"location":"environment/installer-xdebug-php71/#configurer-phpstorm","text":"On va dans Pr\u00e9ference > Language & Framework > PHP Dans Cli Interpreter, on choisi notre php 7.1, et on clique sur les \"...\" On oublie pas de mettre le chemin de l'extension (La valeur de zend_extension) On va dans Run > Edit Configuration > Le bouton + > PHP Web PAGE On cr\u00e9er le serveur Host : Vous mettez l'IP que vous utilisez avec le app/console server:start Port : Pareil On oublie pas de s\u00e9lectionner Xdebug Mapping : Si vous n'en mettez pas, et que vous avez une erreur sans, mettez le m\u00eame chemin \u00e0 droite qu'\u00e0 gauche. On va dans Pr\u00e9ference > Language & Framework > PHP > Debug Tout devrait \u00eatre bon, on va dans Run > Debug , on choisi notre PHP Web Page, et voil\u00e0 !","title":"Configurer PHPStorm"},{"location":"environment/supervisor/","text":"Supervisor avec Oro Documentation http://supervisord.org/running.html Usage 1 Cr\u00e9er un fichier de configuration dans ~/supervisor/cond.d/mon_apppli.conf Oro fournit un mod\u00e8le de fichier de configuration : https://oroinc.com/b2b-ecommerce/doc/current/install-upgrade/installation-quick-start-dev/commerce-crm#configure-and-run-required-background-processes [program:oro_web_socket] command=php ./bin/console gos:websocket:server --env=prod numprocs=1 autostart=true autorestart=true directory=/usr/share/nginx/html/oroapp user=nginx redirect_stderr=true [program:oro_message_consumer] command=php ./bin/console oro:message-queue:consume --env=prod process_name=%(program_name)s_%(process_num)02d numprocs=5 autostart=true autorestart=true directory=/usr/share/nginx/html/oroapp user=nginx redirect_stderr=true Changer les repertoires et le User dans le fichier .conf 2 Lancer supervisorctl update pour qu'il recharge les conf. 3 Lancer supervisorctl status pour voir ce qui tournent Relancer tous les services Lancer supervisortctl restart all","title":"Utilisation de Supervisor"},{"location":"environment/supervisor/#supervisor-avec-oro","text":"","title":"Supervisor avec Oro"},{"location":"environment/supervisor/#documentation","text":"http://supervisord.org/running.html","title":"Documentation"},{"location":"environment/supervisor/#usage","text":"1 Cr\u00e9er un fichier de configuration dans ~/supervisor/cond.d/mon_apppli.conf Oro fournit un mod\u00e8le de fichier de configuration : https://oroinc.com/b2b-ecommerce/doc/current/install-upgrade/installation-quick-start-dev/commerce-crm#configure-and-run-required-background-processes [program:oro_web_socket] command=php ./bin/console gos:websocket:server --env=prod numprocs=1 autostart=true autorestart=true directory=/usr/share/nginx/html/oroapp user=nginx redirect_stderr=true [program:oro_message_consumer] command=php ./bin/console oro:message-queue:consume --env=prod process_name=%(program_name)s_%(process_num)02d numprocs=5 autostart=true autorestart=true directory=/usr/share/nginx/html/oroapp user=nginx redirect_stderr=true Changer les repertoires et le User dans le fichier .conf 2 Lancer supervisorctl update pour qu'il recharge les conf. 3 Lancer supervisorctl status pour voir ce qui tournent Relancer tous les services Lancer supervisortctl restart all","title":"Usage"},{"location":"frontend/BlockTypes/","text":"BlockTypes Some usage examples layout: actions: - '@add': id: style_calendar parentId: head_style blockType: style options: src: 'js/calendar/calendar.css' - '@add': id: script_prototype parentId: head_script blockType: script options: src: 'js/prototype/prototype.js' - '@add': id: meta_description parentId: head blockType: meta options: name: 'description' content: '=data[\"product\"].getDescription()' siblingId: meta - '@add': id : logo blockType: link options: image: logo.png path: / attr: class: logo vars: image_class: large image_alt: Madison Island siblingId: navigation prepend: true - '@add': id : breadcrumbs_product parentId: breadcrumbs blockType: text options: text: '=data[\"product\"].getName()' Commands To have a list of block type : bin/console debug:container --show-private --tag layout.block_type And to have the data providers : bin/console debug:container --show-private --tag layout.data_provider","title":"BlockTypes examples"},{"location":"frontend/BlockTypes/#blocktypes","text":"","title":"BlockTypes"},{"location":"frontend/BlockTypes/#some-usage-examples","text":"layout: actions: - '@add': id: style_calendar parentId: head_style blockType: style options: src: 'js/calendar/calendar.css' - '@add': id: script_prototype parentId: head_script blockType: script options: src: 'js/prototype/prototype.js' - '@add': id: meta_description parentId: head blockType: meta options: name: 'description' content: '=data[\"product\"].getDescription()' siblingId: meta - '@add': id : logo blockType: link options: image: logo.png path: / attr: class: logo vars: image_class: large image_alt: Madison Island siblingId: navigation prepend: true - '@add': id : breadcrumbs_product parentId: breadcrumbs blockType: text options: text: '=data[\"product\"].getName()'","title":"Some usage examples"},{"location":"frontend/BlockTypes/#commands","text":"To have a list of block type : bin/console debug:container --show-private --tag layout.block_type And to have the data providers : bin/console debug:container --show-private --tag layout.data_provider","title":"Commands"},{"location":"frontend/ElementList/","text":"List of Ui element present in OroUIBundle::macros.html.twig Buttons button(parameters) dropdownButton(parameters) dropdownItem(parameters) pinnedDropdownButton(parameters) dropdownSaveButton(parameters) cancelButton(path, label) editButton(parameters) addButton(parameters) deleteButton(parameters) deleteLink(parameters) clientLink(parameters) clientButton(parameters) ajaxButton(parameters) dropdownClientItem(parameters) saveAndCloseButton(parametersOrLabel) saveAndStayButton(parametersOrLabel) saveAndNewButton(parameters) saveActionButton(parameters) buttonType(parameters) buttonSeparator() Others collection_prototype(widget) tooltip(tooltip_raw, tooltip_parameters, tooltip_placement, details_enabled, details_link, details_anchor) attibuteRow(title, value, additionalData) Details Render attribute row Parameters: title - attribute title value - attribute value additionalData - array with additional data\") renderAttribute(title, data, options) Details Render attribute row Parameters: title - attribute title value - attribute value additionalData - array with additional data renderControlGroup(title, data) Details Render attribute row with custom data block Parameters: title - row title data - row data renderProperty(title, data, entity = null, fieldName = null, options = {}) Details Render property block Parameters: title - property title data - property data entity - the entitty instance on wich Field ACL should be checked fieldName - the name of field on wich Field ACL should be checked options - addtional options for property renderHtmlProperty(title, data, entity = null, fieldName = null, options = {}) renderPropertyControlGroup(title, data, entity = null, fieldName = null) renderHtmlPropertyControlGroup(title, data, entity = null, fieldName = null) renderCollapsibleHtmlProperty(title, data, entity, fieldName, moreText = 'Show more', lessText = 'Show less') renderSwitchableHtmlProperty(title, data) renderColorProperty(title, data, empty) link(parameters) renderPageComponentAttributes(pageComponent) renderWidgetAttributes(options) renderWidgetDataAttributes(options) renderAttributes(options, prefix) ajaxLink(parameters) scrollSubblock(title, data, isForm, useSpan, spanClass) scrollBlock(blockId, title, subblocks, isForm, contentAttributes, useSubBlockDivider, headerLinkContent = '') scrollData(dataTarget, data, entity, form = null) collectionField(field, label, buttonCaption, tooltipText = null) attributes(attr, excludes) entityOwnerLink(entity, renderLabel = true) renderUrl(url, text, class, title, attributes) renderUrlWithActions(parameters, entity) renderPhone(phone, title) renderPhoneWithActions(phone, entity) getApplicableForUnderscore(str) renderList(elements) renderTable(titles, rows, style) entityViewLink(entity, label, route, permission) entityViewLinks(entities, labelProperty, route, permission) renderDisabledLabel(labelText) renderEntityViewLabel(entity, fieldName, entityLabelIfNotGranted = null renderJsTree(data, actions) app_logo(organization_name) insertIcon(classNames)","title":"List of Ui element present in OroUIBundle::macros.html.twig"},{"location":"frontend/ElementList/#list-of-ui-element-present-in-orouibundlemacroshtmltwig","text":"","title":"List of Ui element present in OroUIBundle::macros.html.twig"},{"location":"frontend/ElementList/#buttons","text":"button(parameters) dropdownButton(parameters) dropdownItem(parameters) pinnedDropdownButton(parameters) dropdownSaveButton(parameters) cancelButton(path, label) editButton(parameters) addButton(parameters) deleteButton(parameters) deleteLink(parameters) clientLink(parameters) clientButton(parameters) ajaxButton(parameters) dropdownClientItem(parameters) saveAndCloseButton(parametersOrLabel) saveAndStayButton(parametersOrLabel) saveAndNewButton(parameters) saveActionButton(parameters) buttonType(parameters) buttonSeparator()","title":"Buttons"},{"location":"frontend/ElementList/#others","text":"collection_prototype(widget) tooltip(tooltip_raw, tooltip_parameters, tooltip_placement, details_enabled, details_link, details_anchor) attibuteRow(title, value, additionalData) Details Render attribute row Parameters: title - attribute title value - attribute value additionalData - array with additional data\") renderAttribute(title, data, options) Details Render attribute row Parameters: title - attribute title value - attribute value additionalData - array with additional data renderControlGroup(title, data) Details Render attribute row with custom data block Parameters: title - row title data - row data renderProperty(title, data, entity = null, fieldName = null, options = {}) Details Render property block Parameters: title - property title data - property data entity - the entitty instance on wich Field ACL should be checked fieldName - the name of field on wich Field ACL should be checked options - addtional options for property renderHtmlProperty(title, data, entity = null, fieldName = null, options = {}) renderPropertyControlGroup(title, data, entity = null, fieldName = null) renderHtmlPropertyControlGroup(title, data, entity = null, fieldName = null) renderCollapsibleHtmlProperty(title, data, entity, fieldName, moreText = 'Show more', lessText = 'Show less') renderSwitchableHtmlProperty(title, data) renderColorProperty(title, data, empty) link(parameters) renderPageComponentAttributes(pageComponent) renderWidgetAttributes(options) renderWidgetDataAttributes(options) renderAttributes(options, prefix) ajaxLink(parameters) scrollSubblock(title, data, isForm, useSpan, spanClass) scrollBlock(blockId, title, subblocks, isForm, contentAttributes, useSubBlockDivider, headerLinkContent = '') scrollData(dataTarget, data, entity, form = null) collectionField(field, label, buttonCaption, tooltipText = null) attributes(attr, excludes) entityOwnerLink(entity, renderLabel = true) renderUrl(url, text, class, title, attributes) renderUrlWithActions(parameters, entity) renderPhone(phone, title) renderPhoneWithActions(phone, entity) getApplicableForUnderscore(str) renderList(elements) renderTable(titles, rows, style) entityViewLink(entity, label, route, permission) entityViewLinks(entities, labelProperty, route, permission) renderDisabledLabel(labelText) renderEntityViewLabel(entity, fieldName, entityLabelIfNotGranted = null renderJsTree(data, actions) app_logo(organization_name) insertIcon(classNames)","title":"Others"},{"location":"frontend/consent-rgpd/","text":"Ajouter un Consent sur la page d'inscription Configuration / Commerce / Client / Consents Enable user consents feature : 1. D\u00e9cocher Par d\u00e9faut Cocher Enable user consents feature Marketing / Catalogues Web / Cr\u00e9er Noeud de contenu -> Ajouter Page de contenu Contiendra le texte du consent Syst\u00e8me / Consent Manager -> Cr\u00e9er Consent Name : le nom qui apparaitra sur le formulaire d'inscription Content Node : s\u00e9lectionner le noeud de contenu qui contient le texte Configuration / Commerce / Client / Consents Enabled user consents : D\u00e9cocher Par d\u00e9faut Cliquer Add Consent S\u00e9lectionner le consent VIDER LE CACHE","title":"RGPD"},{"location":"frontend/consent-rgpd/#ajouter-un-consent-sur-la-page-dinscription","text":"","title":"Ajouter un Consent sur la page d'inscription"},{"location":"frontend/consent-rgpd/#configuration-commerce-client-consents","text":"Enable user consents feature : 1. D\u00e9cocher Par d\u00e9faut Cocher Enable user consents feature","title":"Configuration / Commerce / Client / Consents"},{"location":"frontend/consent-rgpd/#marketing-catalogues-web-creer-noeud-de-contenu-ajouter-page-de-contenu","text":"Contiendra le texte du consent","title":"Marketing / Catalogues Web / Cr\u00e9er Noeud de contenu -&gt; Ajouter Page de contenu"},{"location":"frontend/consent-rgpd/#systeme-consent-manager-creer-consent","text":"Name : le nom qui apparaitra sur le formulaire d'inscription Content Node : s\u00e9lectionner le noeud de contenu qui contient le texte","title":"Syst\u00e8me / Consent Manager -&gt; Cr\u00e9er Consent"},{"location":"frontend/consent-rgpd/#configuration-commerce-client-consents_1","text":"Enabled user consents : D\u00e9cocher Par d\u00e9faut Cliquer Add Consent S\u00e9lectionner le consent","title":"Configuration / Commerce / Client / Consents"},{"location":"frontend/consent-rgpd/#vider-le-cache","text":"","title":"VIDER LE CACHE"},{"location":"frontend/findblockname/","text":"How to find twig template blocks name Tutorial Open the file TwigRendererEngine.php in vendor Go to the method protected function loadResourceForBlockName($cacheKey, FormView $view, $blockName) Add var_dump($blockName); in the function Reload a page","title":"Find Twig Template block names"},{"location":"frontend/findblockname/#how-to-find-twig-template-blocks-name","text":"","title":"How to find twig template blocks name"},{"location":"frontend/findblockname/#tutorial","text":"Open the file TwigRendererEngine.php in vendor Go to the method protected function loadResourceForBlockName($cacheKey, FormView $view, $blockName) Add var_dump($blockName); in the function Reload a page","title":"Tutorial"},{"location":"frontend/form/","text":"Create a frontend form Create a form Create the frontend controller and declare it in Resource\\config\\oro\\routing.yml like this: my_entity_frontend: resource: '@MyBundle/Controller/Frontend/MyEntityController.php' type: annotation prefix: /myentity options: frontend: true Create a FormProvider in Layout\\DataProvider : use Oro\\Bundle\\LayoutBundle\\Layout\\DataProvider\\AbstractFormProvider; class MyEntityFormProvider extends AbstractFormProvider { /** * @param MyEntity $myEntity * @return FormView */ public function getMyFormView(MyEntity $myEntity) { return $this->getFormView(MyEntityType::class, $myEntity); } } Declare it in the services: my.frontend.form.provider: class: MyBundle\\Layout\\DataProvider\\MyEntityFormProvider arguments: - '@form.factory' - '@router' tags: - { name: layout.data_provider, alias: my_provider_alias } Create a layout.yml in Resources\\views\\layouts\\the theme you use\\layouts\\the name of your page layout: actions: - '@setBlockTheme': themes: 'MyBundle:layouts:default/my_page/my_page.html.twig' - '@addTree': items: container: blockType: container form_start: blockType: form_start options: form: '=data[\"my_provider_alias\"].getMyFormView(data[\"entity\"])' form_fields: blockType: form_fields options: form: '=data[\"my_provider_alias\"].getMyFormView(data[\"entity\"])' form_end: blockType: form_end options: form: '=data[\"my_provider_alias\"].getMyFormView(data[\"entity\"])' form_confirm: blockType: button options: action: submit text: oro.customer.form.action.save.label style: auto attr: 'class': ' btn--large btn--full-in-mobile' tree: page_content: container: form_start: ~ form_fields: ~ form_confirm: ~ form_end: ~ You can now customize how fields are rendered with a twig: {% block _form_fields_widget %} <div class=\"grid__column grid__column--12\"> {{ form_row(form.afield) }} </div> <div class=\"grid__column grid__column--6\"> {{ form_row(form.anotherfield) }} </div> {% endblock %} {% block _container_widget %} <div class=\"login-form\"> {{ block_widget(block) }} </div> {% endblock %}","title":"Create a frontend form for an entity"},{"location":"frontend/form/#create-a-frontend-form","text":"Create a form Create the frontend controller and declare it in Resource\\config\\oro\\routing.yml like this: my_entity_frontend: resource: '@MyBundle/Controller/Frontend/MyEntityController.php' type: annotation prefix: /myentity options: frontend: true Create a FormProvider in Layout\\DataProvider : use Oro\\Bundle\\LayoutBundle\\Layout\\DataProvider\\AbstractFormProvider; class MyEntityFormProvider extends AbstractFormProvider { /** * @param MyEntity $myEntity * @return FormView */ public function getMyFormView(MyEntity $myEntity) { return $this->getFormView(MyEntityType::class, $myEntity); } } Declare it in the services: my.frontend.form.provider: class: MyBundle\\Layout\\DataProvider\\MyEntityFormProvider arguments: - '@form.factory' - '@router' tags: - { name: layout.data_provider, alias: my_provider_alias } Create a layout.yml in Resources\\views\\layouts\\the theme you use\\layouts\\the name of your page layout: actions: - '@setBlockTheme': themes: 'MyBundle:layouts:default/my_page/my_page.html.twig' - '@addTree': items: container: blockType: container form_start: blockType: form_start options: form: '=data[\"my_provider_alias\"].getMyFormView(data[\"entity\"])' form_fields: blockType: form_fields options: form: '=data[\"my_provider_alias\"].getMyFormView(data[\"entity\"])' form_end: blockType: form_end options: form: '=data[\"my_provider_alias\"].getMyFormView(data[\"entity\"])' form_confirm: blockType: button options: action: submit text: oro.customer.form.action.save.label style: auto attr: 'class': ' btn--large btn--full-in-mobile' tree: page_content: container: form_start: ~ form_fields: ~ form_confirm: ~ form_end: ~ You can now customize how fields are rendered with a twig: {% block _form_fields_widget %} <div class=\"grid__column grid__column--12\"> {{ form_row(form.afield) }} </div> <div class=\"grid__column grid__column--6\"> {{ form_row(form.anotherfield) }} </div> {% endblock %} {% block _container_widget %} <div class=\"login-form\"> {{ block_widget(block) }} </div> {% endblock %}","title":"Create a frontend form"},{"location":"frontend/mass-actions/","text":"Le strict n\u00e9cessaire pour ajouter une mass-action sur la grille produit. Les mots rigolos (machin, glouglou, torref, avionAr\u00e9Action et massage-de-pieds) indiquent les alias qui peuvent \u00eatre chang\u00e9s. Resources/oro/config/actions.yml operations: glouglou: label: mass.age.de.pieds datagrids: - frontend-product-search-grid datagrid_options: mass_action: type: addproducts frontend_type: torref # c'est le nom de votre JS sans \"-action.js\" Resources/public/js/datagrid/action/backend-action-header-cell.js piquez backend-action-header-cell.js dans les vendor ligne 102, ajouter votre action : newMassActions['glougloumass_action'] = $.extend(true, {}, avionAr\u00e9Action, { name: 'glougloumass_action' }); ligne 30 : d\u00e9finissez votre action : var avionAr\u00e9Action = { icon: 'copy', # une icone FontAwesome sans \"fa-\" frontend_handle: 'ajax', label: __('mass.age.de.pieds'), type: 'addproducts', frontend_type: 'torref', # le nom de votre JS sans \"-action.js\" route: 'mass_age_de_pieds', # la route handler: 'app.machin.mass_action.handler', # l\u00e0 ou vous mettrez vos traitements }; Ajoutez var __ = require('orotranslation/js/translator'); vers les requires lignes 4 ou 5. Resources/public/js/datagrid/action/torref-action.js piquez add-products-mass-action.js dans les vendor Resources/views/layouts/blank/config/require.js config: paths: 'oro/datagrid/action/torref-action': 'bundles/app/js/datagrid/action/torref-action.js' 'app/js/datagrid/action/backend-action-header-cell': 'bundles/app/js/datagrid/action/backend-action-header-cell.js' map: '*': 'oroproduct/js/app/datagrid/header-cell/backend-action-header-cell': 'app/js/datagrid/action/backend-action-header-cell' Controller/MachinController.php /** * @Route(\"/mass-age-de-pieds/\", name=\"mass_age_de_pieds\") */ public function massAgeDePieds(Request $request) { $gridName = $request->get('gridName'); $actionName = $request->get('actionName'); /** @var MassActionDispatcher $massActionDispatcher */ $massActionDispatcher = $this->get('oro_datagrid.mass_action.dispatcher'); $response = $massActionDispatcher->dispatchByRequest($gridName, $actionName, $request); $data = [ 'successful' => $response->isSuccessful(), 'message' => $response->getMessage() ]; return new JsonResponse(array_merge($data, $response->getOptions())); } Dans routing.yml , le controller doit avoir options.expose: true . MassAction/MachinMassActionHandler.php L\u00e0 ou vous mettez vos traitements. C'est $ids qui vous int\u00e9resse. class MachinMassActionHandler implements MassActionHandlerInterface { public function handle(MassActionHandlerArgs $args) { $argsParser = new AddProductsMassActionArgsParser($args); $ids = $argsParser->getProductIds(); return new MassActionResponse(true, 'message'); } }","title":"Ajouter une Mass-Action sur la grille des produits"},{"location":"frontend/mass-actions/#resourcesoroconfigactionsyml","text":"operations: glouglou: label: mass.age.de.pieds datagrids: - frontend-product-search-grid datagrid_options: mass_action: type: addproducts frontend_type: torref # c'est le nom de votre JS sans \"-action.js\"","title":"Resources/oro/config/actions.yml"},{"location":"frontend/mass-actions/#resourcespublicjsdatagridactionbackend-action-header-celljs","text":"piquez backend-action-header-cell.js dans les vendor ligne 102, ajouter votre action : newMassActions['glougloumass_action'] = $.extend(true, {}, avionAr\u00e9Action, { name: 'glougloumass_action' }); ligne 30 : d\u00e9finissez votre action : var avionAr\u00e9Action = { icon: 'copy', # une icone FontAwesome sans \"fa-\" frontend_handle: 'ajax', label: __('mass.age.de.pieds'), type: 'addproducts', frontend_type: 'torref', # le nom de votre JS sans \"-action.js\" route: 'mass_age_de_pieds', # la route handler: 'app.machin.mass_action.handler', # l\u00e0 ou vous mettrez vos traitements }; Ajoutez var __ = require('orotranslation/js/translator'); vers les requires lignes 4 ou 5.","title":"Resources/public/js/datagrid/action/backend-action-header-cell.js"},{"location":"frontend/mass-actions/#resourcespublicjsdatagridactiontorref-actionjs","text":"piquez add-products-mass-action.js dans les vendor","title":"Resources/public/js/datagrid/action/torref-action.js"},{"location":"frontend/mass-actions/#resourcesviewslayoutsblankconfigrequirejs","text":"config: paths: 'oro/datagrid/action/torref-action': 'bundles/app/js/datagrid/action/torref-action.js' 'app/js/datagrid/action/backend-action-header-cell': 'bundles/app/js/datagrid/action/backend-action-header-cell.js' map: '*': 'oroproduct/js/app/datagrid/header-cell/backend-action-header-cell': 'app/js/datagrid/action/backend-action-header-cell'","title":"Resources/views/layouts/blank/config/require.js"},{"location":"frontend/mass-actions/#controllermachincontrollerphp","text":"/** * @Route(\"/mass-age-de-pieds/\", name=\"mass_age_de_pieds\") */ public function massAgeDePieds(Request $request) { $gridName = $request->get('gridName'); $actionName = $request->get('actionName'); /** @var MassActionDispatcher $massActionDispatcher */ $massActionDispatcher = $this->get('oro_datagrid.mass_action.dispatcher'); $response = $massActionDispatcher->dispatchByRequest($gridName, $actionName, $request); $data = [ 'successful' => $response->isSuccessful(), 'message' => $response->getMessage() ]; return new JsonResponse(array_merge($data, $response->getOptions())); } Dans routing.yml , le controller doit avoir options.expose: true .","title":"Controller/MachinController.php"},{"location":"frontend/mass-actions/#massactionmachinmassactionhandlerphp","text":"L\u00e0 ou vous mettez vos traitements. C'est $ids qui vous int\u00e9resse. class MachinMassActionHandler implements MassActionHandlerInterface { public function handle(MassActionHandlerArgs $args) { $argsParser = new AddProductsMassActionArgsParser($args); $ids = $argsParser->getProductIds(); return new MassActionResponse(true, 'message'); } }","title":"MassAction/MachinMassActionHandler.php"},{"location":"frontend/products-list/","text":"Products list Products at front office are rendered in multiple places. 1) Main product grid (product listing, PLP etc) \u2013 renders grid of products that has pagination, filters and sorters. Datagrid used to render it is called frontend-product-search-grid and defined here: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Resources/config/oro/datagrids.yml#L736-L796 . This grid is extended by multiple listeners that adds additional filters, additional sorters, prices, shopping lists etc. This grid is usually rendered using oro_product_frontend_product_index route from this controller: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Controller/Frontend/ProductController.php#L18-L37 . This page is also used to render global search results. 2) Product view page (product information page, PDP etc) \u2013 renders information about one specific product. It is rendered using oro_product_frontend_product_view route from this controller: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Controller/Frontend/ProductController.php#L39-L103 3) Simplified product listing (e.g. Featured products at the root page) \u2013 renders short list of products without ability to paginate, sort of filter them. It is rendered using oro_product_list layout import. Here you may see how it is done: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Resources/views/layouts/blank/oro_frontend_root/featured_products.yml Of course there are other places where products are rendered, but they are handled from other bundles. You may find them by checking an appropriate route and associated layout updates.","title":"Product List"},{"location":"frontend/products-list/#products-list","text":"Products at front office are rendered in multiple places. 1) Main product grid (product listing, PLP etc) \u2013 renders grid of products that has pagination, filters and sorters. Datagrid used to render it is called frontend-product-search-grid and defined here: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Resources/config/oro/datagrids.yml#L736-L796 . This grid is extended by multiple listeners that adds additional filters, additional sorters, prices, shopping lists etc. This grid is usually rendered using oro_product_frontend_product_index route from this controller: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Controller/Frontend/ProductController.php#L18-L37 . This page is also used to render global search results. 2) Product view page (product information page, PDP etc) \u2013 renders information about one specific product. It is rendered using oro_product_frontend_product_view route from this controller: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Controller/Frontend/ProductController.php#L39-L103 3) Simplified product listing (e.g. Featured products at the root page) \u2013 renders short list of products without ability to paginate, sort of filter them. It is rendered using oro_product_list layout import. Here you may see how it is done: https://github.com/oroinc/orocommerce/blob/3.1.0-rc/src/Oro/Bundle/ProductBundle/Resources/views/layouts/blank/oro_frontend_root/featured_products.yml Of course there are other places where products are rendered, but they are handled from other bundles. You may find them by checking an appropriate route and associated layout updates.","title":"Products list"},{"location":"migrations/businessUnit/","text":"Business Unit migration Extending the BusinessUnit entity Extending the BusinessUnit entity is rather easy. Just create a new class in the [Bundle]\\Migrations\\Schema\\vx_x namespace and make it implement the Oro\\Bundle\\MigrationBundle\\Migration\\Migration interface (and eventually the Oro\\Bundle\\AttachmentBundle\\Migration\\Extension\\AttachmentExtensionAwareInterface if you need to have attachments to your entity, like images or any files). Below is an example from kiboko-labs/sevea-orocommerce : <?php namespace Kiboko\\Bundle\\AppBundle\\Migrations\\Schema\\v1_0; use Doctrine\\DBAL\\Schema\\Schema; use Oro\\Bundle\\AttachmentBundle\\Migration\\Extension\\AttachmentExtension; use Oro\\Bundle\\AttachmentBundle\\Migration\\Extension\\AttachmentExtensionAwareInterface; use Oro\\Bundle\\EntityExtendBundle\\EntityConfig\\ExtendScope; use Oro\\Bundle\\EntityExtendBundle\\Migration\\OroOptions; use Oro\\Bundle\\MigrationBundle\\Migration\\Migration; use Oro\\Bundle\\MigrationBundle\\Migration\\QueryBag; class CustomizeBusinessUnit implements Migration, AttachmentExtensionAwareInterface { const TABLE_NAME = 'oro_business_unit'; const THUMB_WIDTH = 200; const THUMB_HEIGHT = 200; const IMAGE_SIZE = 2; /** @var AttachmentExtension */ protected $attachmentExtension; /** * Sets the AttachmentExtension * * @param AttachmentExtension $attachmentExtension */ public function setAttachmentExtension(AttachmentExtension $attachmentExtension) { $this->attachmentExtension = $attachmentExtension; } /** * Modifies the given schema to apply necessary changes of a database * The given query bag can be used to apply additional SQL queries before and after schema changes * * @param Schema $schema * @param QueryBag $queries * @return void * @throws \\Doctrine\\DBAL\\Schema\\SchemaException */ public function up(Schema $schema, QueryBag $queries) { $table = $schema->getTable(self::TABLE_NAME); $table->addColumn('address', 'string', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM, 'entity' => ['description' => 'The address of the business unit']], 'view' => ['priority' => 200], ], ]); $table->addColumn('address_details', 'string', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 190], ], ]); $table->addColumn('postal_code', 'string', [ 'length' => 5, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 180], ], ]); $table->addColumn('town', 'string', [ 'length' => 100, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 170], ], ]); $table->addColumn('longitude', 'float', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 160], ], ]); $table->addColumn('latitude', 'float', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 150], ], ]); $table->addColumn('type', 'string', [ 'length' => 10, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 140], ], ]); $table->addColumn('erp_code', 'string', [ 'length' => 20, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 120], ], ]); $table->addColumn('facebook', 'string', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 110], ], ]); $this->attachmentExtension->addImageRelation( $schema, self::TABLE_NAME, 'image', [], self::IMAGE_SIZE, self::THUMB_WIDTH, self::THUMB_HEIGHT ); } } Be very careful ! If you mistake, it's possible you'll have to run the oro:install command again. Oro keeps memory of the previous structure in database (table oro_entity_config_field ), stored base64 serialized BLOB field. Really difficult to update. Extending the BusinessUnitType You have to write a new type extension in order to add and configure the fields of the form. You may create new fields, and override \"parent\" field configurations. <?php namespace Kiboko\\Bundle\\AppBundle\\Form\\Extension; use Oro\\Bundle\\AttachmentBundle\\Form\\Type\\ImageType; use Oro\\Bundle\\OrganizationBundle\\Form\\Type\\BusinessUnitType; use Symfony\\Component\\Form\\AbstractTypeExtension; use Symfony\\Component\\Form\\Extension\\Core\\Type\\ChoiceType; use Symfony\\Component\\Form\\FormBuilderInterface; class BusinessUnitExtension extends AbstractTypeExtension { const TYPE_VENDOR = 'vendor'; const TYPE_VITRINE = 'vitrine'; const TYPE_EXTERNAL = 'external'; /** * Returns the name of the type being extended. * * @return string The name of the type being extended */ public function getExtendedType() { return BusinessUnitType::class; } /** * @param FormBuilderInterface $builder * @param array $options */ public function buildForm(FormBuilderInterface $builder, array $options) { $builder ->add('image', ImageType::class) ->add('type', ChoiceType::class, [ 'label' => $this->getTranslationKey('type'), 'choices' => [ $this->getTranslationKey('type.choices.vendor') => self::TYPE_VENDOR, $this->getTranslationKey('type.choices.vitrine') => self::TYPE_VITRINE, $this->getTranslationKey('type.choices.external') => self::TYPE_EXTERNAL, ] ]) ; } private function getTranslationKey(string $key) : string { return sprintf('oro.organization.businessunit.%s.label', $key); } } Creating the form listener New fields declared in the type extension above won't be added automatically on the form view. In order to add those fields on the form view, we need to hook into the form prerender event Oro\\Bundle\\UIBundle\\Event\\Events::BEFORE_UPDATE_FORM_RENDER . <?php namespace Kiboko\\Bundle\\AppBundle\\EventListener; use Oro\\Bundle\\UIBundle\\Event\\BeforeFormRenderEvent; use Oro\\Bundle\\UIBundle\\Event\\Events; use Oro\\Bundle\\UIBundle\\View\\ScrollData; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Form\\FormView; class BusinessUnitFormListener implements EventSubscriberInterface { const FORM_NAME = 'oro_business_unit_form'; /** * @return array The event names to listen to */ public static function getSubscribedEvents() { return [ Events::BEFORE_UPDATE_FORM_RENDER => 'onBusinessUnitEdit', ]; } public function onBusinessUnitEdit(BeforeFormRenderEvent $event) { $form = $event->getForm(); if (!$this->supports($form)) { return; } $template = $event->getTwigEnvironment()->render( '@KibokoApp/Form/file_widget.html.twig', ['form' => $form->children['image']] ); $scrollData = new ScrollData($event->getFormData()); $scrollData->addSubBlockData(1, 0, $template, 'image'); $event->setFormData($scrollData->getData()); } /** * @param FormView $formView * @return bool */ protected function supports(FormView $formView) { return $formView->vars['name'] === self::FORM_NAME; } } Be careful, as each form rendering will trigger this event. Be sure to filter the forms with a supports method as above, for example The form data can be found via the BeforeFormRenderEvent . It's just a flat array, that is easier to manipulate wrapped into a Oro\\Bundle\\UIBundle\\View\\ScrollData object. The goal is to generate the HTML for each added form field: $template = $event->getTwigEnvironment()->render( '@KibokoApp/Form/file_widget.html.twig', ['form' => $form->children['image']] ); and to place it at the required place in the form data: $scrollData->addSubBlockData(1, 0, $template, 'image'); You'll have to create the template file yourself. In the above example ( file_widget.html.twig ), it's just a one-line template: {{ form_row(form) }}","title":"Extending an entity (Business Unit example)"},{"location":"migrations/businessUnit/#business-unit-migration","text":"","title":"Business Unit migration"},{"location":"migrations/businessUnit/#extending-the-businessunit-entity","text":"Extending the BusinessUnit entity is rather easy. Just create a new class in the [Bundle]\\Migrations\\Schema\\vx_x namespace and make it implement the Oro\\Bundle\\MigrationBundle\\Migration\\Migration interface (and eventually the Oro\\Bundle\\AttachmentBundle\\Migration\\Extension\\AttachmentExtensionAwareInterface if you need to have attachments to your entity, like images or any files). Below is an example from kiboko-labs/sevea-orocommerce : <?php namespace Kiboko\\Bundle\\AppBundle\\Migrations\\Schema\\v1_0; use Doctrine\\DBAL\\Schema\\Schema; use Oro\\Bundle\\AttachmentBundle\\Migration\\Extension\\AttachmentExtension; use Oro\\Bundle\\AttachmentBundle\\Migration\\Extension\\AttachmentExtensionAwareInterface; use Oro\\Bundle\\EntityExtendBundle\\EntityConfig\\ExtendScope; use Oro\\Bundle\\EntityExtendBundle\\Migration\\OroOptions; use Oro\\Bundle\\MigrationBundle\\Migration\\Migration; use Oro\\Bundle\\MigrationBundle\\Migration\\QueryBag; class CustomizeBusinessUnit implements Migration, AttachmentExtensionAwareInterface { const TABLE_NAME = 'oro_business_unit'; const THUMB_WIDTH = 200; const THUMB_HEIGHT = 200; const IMAGE_SIZE = 2; /** @var AttachmentExtension */ protected $attachmentExtension; /** * Sets the AttachmentExtension * * @param AttachmentExtension $attachmentExtension */ public function setAttachmentExtension(AttachmentExtension $attachmentExtension) { $this->attachmentExtension = $attachmentExtension; } /** * Modifies the given schema to apply necessary changes of a database * The given query bag can be used to apply additional SQL queries before and after schema changes * * @param Schema $schema * @param QueryBag $queries * @return void * @throws \\Doctrine\\DBAL\\Schema\\SchemaException */ public function up(Schema $schema, QueryBag $queries) { $table = $schema->getTable(self::TABLE_NAME); $table->addColumn('address', 'string', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM, 'entity' => ['description' => 'The address of the business unit']], 'view' => ['priority' => 200], ], ]); $table->addColumn('address_details', 'string', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 190], ], ]); $table->addColumn('postal_code', 'string', [ 'length' => 5, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 180], ], ]); $table->addColumn('town', 'string', [ 'length' => 100, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 170], ], ]); $table->addColumn('longitude', 'float', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 160], ], ]); $table->addColumn('latitude', 'float', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 150], ], ]); $table->addColumn('type', 'string', [ 'length' => 10, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 140], ], ]); $table->addColumn('erp_code', 'string', [ 'length' => 20, OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 120], ], ]); $table->addColumn('facebook', 'string', [ OroOptions::KEY => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 110], ], ]); $this->attachmentExtension->addImageRelation( $schema, self::TABLE_NAME, 'image', [], self::IMAGE_SIZE, self::THUMB_WIDTH, self::THUMB_HEIGHT ); } } Be very careful ! If you mistake, it's possible you'll have to run the oro:install command again. Oro keeps memory of the previous structure in database (table oro_entity_config_field ), stored base64 serialized BLOB field. Really difficult to update.","title":"Extending the BusinessUnit entity"},{"location":"migrations/businessUnit/#extending-the-businessunittype","text":"You have to write a new type extension in order to add and configure the fields of the form. You may create new fields, and override \"parent\" field configurations. <?php namespace Kiboko\\Bundle\\AppBundle\\Form\\Extension; use Oro\\Bundle\\AttachmentBundle\\Form\\Type\\ImageType; use Oro\\Bundle\\OrganizationBundle\\Form\\Type\\BusinessUnitType; use Symfony\\Component\\Form\\AbstractTypeExtension; use Symfony\\Component\\Form\\Extension\\Core\\Type\\ChoiceType; use Symfony\\Component\\Form\\FormBuilderInterface; class BusinessUnitExtension extends AbstractTypeExtension { const TYPE_VENDOR = 'vendor'; const TYPE_VITRINE = 'vitrine'; const TYPE_EXTERNAL = 'external'; /** * Returns the name of the type being extended. * * @return string The name of the type being extended */ public function getExtendedType() { return BusinessUnitType::class; } /** * @param FormBuilderInterface $builder * @param array $options */ public function buildForm(FormBuilderInterface $builder, array $options) { $builder ->add('image', ImageType::class) ->add('type', ChoiceType::class, [ 'label' => $this->getTranslationKey('type'), 'choices' => [ $this->getTranslationKey('type.choices.vendor') => self::TYPE_VENDOR, $this->getTranslationKey('type.choices.vitrine') => self::TYPE_VITRINE, $this->getTranslationKey('type.choices.external') => self::TYPE_EXTERNAL, ] ]) ; } private function getTranslationKey(string $key) : string { return sprintf('oro.organization.businessunit.%s.label', $key); } }","title":"Extending the BusinessUnitType"},{"location":"migrations/businessUnit/#creating-the-form-listener","text":"New fields declared in the type extension above won't be added automatically on the form view. In order to add those fields on the form view, we need to hook into the form prerender event Oro\\Bundle\\UIBundle\\Event\\Events::BEFORE_UPDATE_FORM_RENDER . <?php namespace Kiboko\\Bundle\\AppBundle\\EventListener; use Oro\\Bundle\\UIBundle\\Event\\BeforeFormRenderEvent; use Oro\\Bundle\\UIBundle\\Event\\Events; use Oro\\Bundle\\UIBundle\\View\\ScrollData; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\Form\\FormView; class BusinessUnitFormListener implements EventSubscriberInterface { const FORM_NAME = 'oro_business_unit_form'; /** * @return array The event names to listen to */ public static function getSubscribedEvents() { return [ Events::BEFORE_UPDATE_FORM_RENDER => 'onBusinessUnitEdit', ]; } public function onBusinessUnitEdit(BeforeFormRenderEvent $event) { $form = $event->getForm(); if (!$this->supports($form)) { return; } $template = $event->getTwigEnvironment()->render( '@KibokoApp/Form/file_widget.html.twig', ['form' => $form->children['image']] ); $scrollData = new ScrollData($event->getFormData()); $scrollData->addSubBlockData(1, 0, $template, 'image'); $event->setFormData($scrollData->getData()); } /** * @param FormView $formView * @return bool */ protected function supports(FormView $formView) { return $formView->vars['name'] === self::FORM_NAME; } } Be careful, as each form rendering will trigger this event. Be sure to filter the forms with a supports method as above, for example The form data can be found via the BeforeFormRenderEvent . It's just a flat array, that is easier to manipulate wrapped into a Oro\\Bundle\\UIBundle\\View\\ScrollData object. The goal is to generate the HTML for each added form field: $template = $event->getTwigEnvironment()->render( '@KibokoApp/Form/file_widget.html.twig', ['form' => $form->children['image']] ); and to place it at the required place in the form data: $scrollData->addSubBlockData(1, 0, $template, 'image'); You'll have to create the template file yourself. In the above example ( file_widget.html.twig ), it's just a one-line template: {{ form_row(form) }}","title":"Creating the form listener"},{"location":"migrations/configuration/","text":"Configuring the platform via migrations The oro:migration:data:load command may also be used to set up a default configuration for the platform. This configuration can be changed programatically thanks to the Oro\\Bundle\\ConfigBundle\\Config\\ConfigManager . Here's an example of implementation: // AppBundle/Migrations/Data/ORM/Configuration.php <?php namespace Kiboko\\Bundle\\AppBundle\\Migrations\\Data\\ORM; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Oro\\Bundle\\ConfigBundle\\Config\\ConfigManager; use Oro\\Bundle\\MigrationBundle\\Fixture\\VersionedFixtureInterface; use Symfony\\Component\\DependencyInjection\\ContainerAwareInterface; use Symfony\\Component\\DependencyInjection\\ContainerInterface; abstract class Configuration extends AbstractFixture implements ContainerAwareInterface, VersionedFixtureInterface { /** @var ConfigManager */ protected $configManager; abstract protected function configure(); /** * Sets the container. * @param ContainerInterface|null $container */ public function setContainer(ContainerInterface $container = null) { $this->configManager = $container->get('oro_config.global'); } /** @var ObjectManager */ public function load(ObjectManager $manager) { $this->configure(); $this->configManager->flush(); } } // AppBundle/Migrations/Data/ORM/GuestAccessConfiguration.php <?php namespace Kiboko\\Bundle\\AppBundle\\Migrations\\Data\\ORM; class GuestAccessConfiguration extends Configuration { const VERSION = '1.0'; /** * @return string */ public function getVersion() { return self::VERSION; } protected function configure() { // Allow website access to guest users $this->configManager->set('oro_frontend.guest_access_enabled', true); // Enable guest checkout $this->configManager->set('oro_checkout.guest_checkout', true); // Enable guest shopping list $this->configManager->set('oro_shopping_list.availability_for_guests', true); // Disable quick order form for guest users $this->configManager->set('oro_product.guest_quick_order_form', false); // Disable guest RFQ $this->configManager->set('oro_rfp.guest_rfp', false); } } The set method of $this->configManager allows to change the value of the specified setting. The setting code is passed as first argument, and the value to be set as second argument. The setting code is formatted according to the following pattern: <section>.<name> . The table below lists a few settings that may be changed with the configuration manager service: section name type description oro_checkout guest_checkout boolean Enable/disable guest checkout oro_frontend guest_access_enabled boolean Enable/disable guest access oro_frontend frontend_theme string Set the theme for the frontend oro_shopping_list availability_for_guests boolean Enable/disable guest shopping list oro_product guest_quick_order_form boolean Enable/disable quick order form for guests oro_product single_unit_mode boolean Enable/disable Product Single Unit Mode oro_product single_unit_mode_show_code boolean Show/hide the product unit code oro_rfp guest_rfp boolean Enable/disable guest rfp oro_currency default_currency string Sets the default platform currency oro_multi_currency allowed_currencies string[] Sets the allowed currencies This list is obviously non exhaustive. TIP: To find out the code of a setting we want to change, we can change it with the UI and then query the oro_config_value table: select * from oro_config_value order by id desc . The section code and the name of the setting are displayed in the result columns.","title":"Configuring the platform via migrations"},{"location":"migrations/configuration/#configuring-the-platform-via-migrations","text":"The oro:migration:data:load command may also be used to set up a default configuration for the platform. This configuration can be changed programatically thanks to the Oro\\Bundle\\ConfigBundle\\Config\\ConfigManager . Here's an example of implementation: // AppBundle/Migrations/Data/ORM/Configuration.php <?php namespace Kiboko\\Bundle\\AppBundle\\Migrations\\Data\\ORM; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Oro\\Bundle\\ConfigBundle\\Config\\ConfigManager; use Oro\\Bundle\\MigrationBundle\\Fixture\\VersionedFixtureInterface; use Symfony\\Component\\DependencyInjection\\ContainerAwareInterface; use Symfony\\Component\\DependencyInjection\\ContainerInterface; abstract class Configuration extends AbstractFixture implements ContainerAwareInterface, VersionedFixtureInterface { /** @var ConfigManager */ protected $configManager; abstract protected function configure(); /** * Sets the container. * @param ContainerInterface|null $container */ public function setContainer(ContainerInterface $container = null) { $this->configManager = $container->get('oro_config.global'); } /** @var ObjectManager */ public function load(ObjectManager $manager) { $this->configure(); $this->configManager->flush(); } } // AppBundle/Migrations/Data/ORM/GuestAccessConfiguration.php <?php namespace Kiboko\\Bundle\\AppBundle\\Migrations\\Data\\ORM; class GuestAccessConfiguration extends Configuration { const VERSION = '1.0'; /** * @return string */ public function getVersion() { return self::VERSION; } protected function configure() { // Allow website access to guest users $this->configManager->set('oro_frontend.guest_access_enabled', true); // Enable guest checkout $this->configManager->set('oro_checkout.guest_checkout', true); // Enable guest shopping list $this->configManager->set('oro_shopping_list.availability_for_guests', true); // Disable quick order form for guest users $this->configManager->set('oro_product.guest_quick_order_form', false); // Disable guest RFQ $this->configManager->set('oro_rfp.guest_rfp', false); } } The set method of $this->configManager allows to change the value of the specified setting. The setting code is passed as first argument, and the value to be set as second argument. The setting code is formatted according to the following pattern: <section>.<name> . The table below lists a few settings that may be changed with the configuration manager service: section name type description oro_checkout guest_checkout boolean Enable/disable guest checkout oro_frontend guest_access_enabled boolean Enable/disable guest access oro_frontend frontend_theme string Set the theme for the frontend oro_shopping_list availability_for_guests boolean Enable/disable guest shopping list oro_product guest_quick_order_form boolean Enable/disable quick order form for guests oro_product single_unit_mode boolean Enable/disable Product Single Unit Mode oro_product single_unit_mode_show_code boolean Show/hide the product unit code oro_rfp guest_rfp boolean Enable/disable guest rfp oro_currency default_currency string Sets the default platform currency oro_multi_currency allowed_currencies string[] Sets the allowed currencies This list is obviously non exhaustive. TIP: To find out the code of a setting we want to change, we can change it with the UI and then query the oro_config_value table: select * from oro_config_value order by id desc . The section code and the name of the setting are displayed in the result columns.","title":"Configuring the platform via migrations"},{"location":"migrations/delete-completely-an-enum/","text":"<?php namespace Test\\Bundle\\ProductBundle\\Migrations\\Schema\\v1_1; use Doctrine\\DBAL\\Schema\\ForeignKeyConstraint; use Doctrine\\DBAL\\Schema\\Index; use Doctrine\\DBAL\\Schema\\Schema; use Doctrine\\DBAL\\Schema\\Table; use Marello\\Bundle\\ProductBundle\\Entity\\Product; use Marello\\Bundle\\SalesBundle\\Entity\\SalesChannel; use Oro\\Bundle\\EntityConfigBundle\\Migration as ConfigMigration; use Oro\\Bundle\\EntityExtendBundle\\Migration\\Extension\\ExtendExtensionAwareInterface; use Oro\\Bundle\\MigrationBundle\\Migration\\Migration; use Oro\\Bundle\\MigrationBundle\\Migration\\QueryBag; use Oro\\Bundle\\EntityExtendBundle\\Migration\\Extension\\ExtendExtension; use Test\\Bundle\\OrderBundle\\Migration\\Extensions\\EntityMetadataExtension; use Test\\Bundle\\OrderBundle\\Migration\\Extensions\\EntityMetadataExtensionAwareInterface; use Test\\Bundle\\SalesBundle\\Entity\\CosmeticChannelConstraint; class RemoveEnumMigrations implements Migration, ExtendExtensionAwareInterface, EntityMetadataExtensionAwareInterface { /** @var ExtendExtension */ protected $extendExtension; /** @var EntityMetadataExtension */ protected $entityMetadataExtension; /** * Sets the ExtendExtension * * @param ExtendExtension $extendExtension */ public function setExtendExtension(ExtendExtension $extendExtension) { $this->extendExtension = $extendExtension; } /** * Sets the EntityMetadataExtension * * @param EntityMetadataExtension $entityMetadataExtension */ public function setEntityMetadataExtension(EntityMetadataExtension $entityMetadataExtension) { $this->entityMetadataExtension = $entityMetadataExtension; } /** * {@inheritdoc} */ public function up(Schema $schema, QueryBag $queries) { $this->removeConfiguration($queries); $this->cleanMarelloProductTable($schema); $this->removeFakeEnumTable($schema); } /** * @param Schema $schema * @throws \\Doctrine\\DBAL\\Schema\\SchemaException */ public function cleanMarelloProductTable(Schema $schema) { $table = $schema->getTable('marello_product_product'); if ($table->hasColumn('fake_attribute_id')) { foreach ($this->getForeignKeys($table, ['fake_attribute_id']) as $foreignKey) { $table->removeForeignKey($foreignKey->getName()); } foreach ($this->getColumnIndexes($table, ['fake_attribute_id']) as $index) { $table->dropIndex($index->getName()); } $table->dropColumn('fake_attribute_id'); } } /** * @param Schema $schema */ public function removeFakeEnumTable(Schema $schema) { if (!$schema->hasTable('oro_enum_marello_product_fake')) { return; } $schema->dropTable('oro_enum_marello_product_fake'); } /** * @param QueryBag $queries */ public function removeConfiguration(QueryBag $queries) { $queries->addQuery( new ConfigMigration\\RemoveEnumFieldQuery( Product::class, 'fake' ) ); } /** * @param Table $table * @param array $columnNames * @return Index[] */ private function getColumnIndexes(Table $table, array $columnNames) { return array_filter($table->getIndexes(), function (Index $index) use ($columnNames) { return count(array_diff($columnNames, $index->getColumns())) === 0 && count(array_diff($index->getColumns(), $columnNames)) === 0; }); } /** * @param Table $table * @param array $columnNames * @return ForeignKeyConstraint[] */ private function getForeignKeys(Table $table, array $columnNames) { return array_filter($table->getForeignKeys(), function (ForeignKeyConstraint $foreignKey) use ($columnNames) { return count(array_diff($columnNames, $foreignKey->getColumns())) === 0 && count(array_diff($foreignKey->getColumns(), $columnNames)) === 0; }); } }","title":"Delete completely an enum"},{"location":"migrations/enum/","text":"================ Schema installer/updater class In addition to what you have read in the the introduction , this migration class must also implement Oro\\Bundle\\EntityExtendBundle\\Migration\\Extension\\ExtendExtensionAwareInterface Then in your up() method, add the enum declaration as shown in the following snippet: <?php /** * {@inheritdoc} */ public function up(Schema $schema, QueryBag $queries) { $enumCode = 'foo_bar'; $this->extendExtension->addEnumField( $schema, $schema->getTable('marello_order_order'), $enumCode, ExtendHelper::buildEnumCode($enumCode), false, false, [ 'extend' => [ 'is_extend' => true, 'owner' => ExtendScope::OWNER_CUSTOM ], 'datagrid' => [ 'is_visible' => false ], 'dataaudit' => [ 'auditable' => false ], 'merge' => [ 'display' => true ], ] ); } Data fixtures installer/updater class After reading the introduction about data fixtures, add the enum values as shown in the following snippet: <?php use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Gedmo\\Translatable\\Entity\\Repository\\TranslationRepository; use Oro\\Bundle\\EntityExtendBundle\\Entity\\Repository\\EnumValueRepository; use Oro\\Bundle\\EntityExtendBundle\\Tools\\ExtendHelper; class LoadLabelData extends AbstractFixture { /** @var array */ private $data = [ [ 'label' => [ 'en' => 'Lorem ipsum', 'fr' => 'Dolor sit', ], 'priority' => 1, 'default' => true ], [ 'label' => [ 'en' => 'Amet consecutir', 'fr' => 'Doloes sit amet', ], 'priority' => 2, 'default' => false ], ]; private $translations = ['fr']; /** * @param ObjectManager $manager */ public function load(ObjectManager $manager) { $enumCode = 'foo_bar'; /** @var TranslationRepository $translationRepository */ $translationRepository = $manager->getRepository('OroEntityExtendBundle:EnumValueTranslation'); $className = ExtendHelper::buildEnumValueClassName($enumCode); /** @var EnumValueRepository $enumRepo */ $enumRepo = $manager->getRepository($className); foreach ($this->data as $option) { // Save english value $enumOption = $enumRepo->createEnumValue( $option['label']['en'], $option['priority'], $option['default'] ); $manager->persist($enumOption); foreach ($this->translations as $locale) { if (!isset($option['label'][$locale])) { continue; } $translationRepository->translate( $enumOption, 'name', $locale, $option['label'][$locale] ); } } $manager->flush(); } } Delete an enum In your migration/update class, add the following snippet: <?php $queries->addPreQuery( new RemoveEnumFieldQuery(Foo::class, 'foo_bar') );","title":"Managing enums"},{"location":"migrations/enum/#schema-installerupdater-class","text":"In addition to what you have read in the the introduction , this migration class must also implement Oro\\Bundle\\EntityExtendBundle\\Migration\\Extension\\ExtendExtensionAwareInterface Then in your up() method, add the enum declaration as shown in the following snippet: <?php /** * {@inheritdoc} */ public function up(Schema $schema, QueryBag $queries) { $enumCode = 'foo_bar'; $this->extendExtension->addEnumField( $schema, $schema->getTable('marello_order_order'), $enumCode, ExtendHelper::buildEnumCode($enumCode), false, false, [ 'extend' => [ 'is_extend' => true, 'owner' => ExtendScope::OWNER_CUSTOM ], 'datagrid' => [ 'is_visible' => false ], 'dataaudit' => [ 'auditable' => false ], 'merge' => [ 'display' => true ], ] ); }","title":"Schema installer/updater class"},{"location":"migrations/enum/#data-fixtures-installerupdater-class","text":"After reading the introduction about data fixtures, add the enum values as shown in the following snippet: <?php use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Gedmo\\Translatable\\Entity\\Repository\\TranslationRepository; use Oro\\Bundle\\EntityExtendBundle\\Entity\\Repository\\EnumValueRepository; use Oro\\Bundle\\EntityExtendBundle\\Tools\\ExtendHelper; class LoadLabelData extends AbstractFixture { /** @var array */ private $data = [ [ 'label' => [ 'en' => 'Lorem ipsum', 'fr' => 'Dolor sit', ], 'priority' => 1, 'default' => true ], [ 'label' => [ 'en' => 'Amet consecutir', 'fr' => 'Doloes sit amet', ], 'priority' => 2, 'default' => false ], ]; private $translations = ['fr']; /** * @param ObjectManager $manager */ public function load(ObjectManager $manager) { $enumCode = 'foo_bar'; /** @var TranslationRepository $translationRepository */ $translationRepository = $manager->getRepository('OroEntityExtendBundle:EnumValueTranslation'); $className = ExtendHelper::buildEnumValueClassName($enumCode); /** @var EnumValueRepository $enumRepo */ $enumRepo = $manager->getRepository($className); foreach ($this->data as $option) { // Save english value $enumOption = $enumRepo->createEnumValue( $option['label']['en'], $option['priority'], $option['default'] ); $manager->persist($enumOption); foreach ($this->translations as $locale) { if (!isset($option['label'][$locale])) { continue; } $translationRepository->translate( $enumOption, 'name', $locale, $option['label'][$locale] ); } } $manager->flush(); } }","title":"Data fixtures installer/updater class"},{"location":"migrations/enum/#delete-an-enum","text":"In your migration/update class, add the following snippet: <?php $queries->addPreQuery( new RemoveEnumFieldQuery(Foo::class, 'foo_bar') );","title":"Delete an enum"},{"location":"migrations/introduction/","text":"How to handle Migrations Schema manipulation Schema installer Declare a migration class in your bundle (eg. FooBundle/Migrations/Schema/ ) This class must implement Oro\\Bundle\\MigrationBundle\\Migration\\Installation Schema updater Declare a migration class in your bundle (eg. FooBundle/Migrations/Schema/v1_6 ), where v1_6 is your version number This class must implement Oro\\Bundle\\MigrationBundle\\Migration\\Migration Data fixtures manipulation Data fixtures installer Declare a migration class in your bundle (eg. FooBundle/Migrations/Data/ORM/ ) This class must extend Doctrine\\Common\\DataFixtures\\AbstractFixture and implement Oro\\Bundle\\MigrationBundle\\Fixture\\VersionedFixtureInterface Data fixtures updater Declare a migration class in your bundle (eg. FooBundle/Migrations/Data/ORM/v1_6/ ), where v1_6 is your version number This class must extend Doctrine\\Common\\DataFixtures\\AbstractFixture Going further How-To: create an Enum","title":"Introduction schema manipulation"},{"location":"migrations/introduction/#how-to-handle-migrations","text":"","title":"How to handle Migrations"},{"location":"migrations/introduction/#schema-manipulation","text":"","title":"Schema manipulation"},{"location":"migrations/introduction/#schema-installer","text":"Declare a migration class in your bundle (eg. FooBundle/Migrations/Schema/ ) This class must implement Oro\\Bundle\\MigrationBundle\\Migration\\Installation","title":"Schema installer"},{"location":"migrations/introduction/#schema-updater","text":"Declare a migration class in your bundle (eg. FooBundle/Migrations/Schema/v1_6 ), where v1_6 is your version number This class must implement Oro\\Bundle\\MigrationBundle\\Migration\\Migration","title":"Schema updater"},{"location":"migrations/introduction/#data-fixtures-manipulation","text":"","title":"Data fixtures manipulation"},{"location":"migrations/introduction/#data-fixtures-installer","text":"Declare a migration class in your bundle (eg. FooBundle/Migrations/Data/ORM/ ) This class must extend Doctrine\\Common\\DataFixtures\\AbstractFixture and implement Oro\\Bundle\\MigrationBundle\\Fixture\\VersionedFixtureInterface","title":"Data fixtures installer"},{"location":"migrations/introduction/#data-fixtures-updater","text":"Declare a migration class in your bundle (eg. FooBundle/Migrations/Data/ORM/v1_6/ ), where v1_6 is your version number This class must extend Doctrine\\Common\\DataFixtures\\AbstractFixture","title":"Data fixtures updater"},{"location":"migrations/introduction/#going-further","text":"How-To: create an Enum","title":"Going further"},{"location":"migrations/view/","text":"View Ordering the fields on the different views (full, create, update) By default, the order the fields are displayed on the views is determined by the system, and can change each time the cache is cleared. To avoid that and force the ordering of the fields, you need to set the oro_options as follows: public function up(Schema $schema, QueryBag $queries) { $table = $schema->getTable(self::TABLE_NAME); $table->addColumn('address', 'string', [ 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 199], ], ]); $table->addColumn('address_details', 'string', [ 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 198], ], ]); $table->addColumn('postal_code', 'string', [ 'length' => 5, 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 197], ], ]); $table->addColumn('town', 'string', [ 'length' => 100, 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 196], ], ]); } The value of 'owner' => ExtendScope::OWNER_CUSTOM tells the system to handle almost everything, so that you do not have to write a new form type for instance. The option 'view' => ['priority' => 199] allows developers to force the ordering of the fields in the view. The higher the value, the higher in the view.","title":"Managing the fields order on the form view"},{"location":"migrations/view/#view","text":"","title":"View"},{"location":"migrations/view/#ordering-the-fields-on-the-different-views-full-create-update","text":"By default, the order the fields are displayed on the views is determined by the system, and can change each time the cache is cleared. To avoid that and force the ordering of the fields, you need to set the oro_options as follows: public function up(Schema $schema, QueryBag $queries) { $table = $schema->getTable(self::TABLE_NAME); $table->addColumn('address', 'string', [ 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 199], ], ]); $table->addColumn('address_details', 'string', [ 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 198], ], ]); $table->addColumn('postal_code', 'string', [ 'length' => 5, 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 197], ], ]); $table->addColumn('town', 'string', [ 'length' => 100, 'oro_options' => [ 'extend' => ['owner' => ExtendScope::OWNER_CUSTOM], 'view' => ['priority' => 196], ], ]); } The value of 'owner' => ExtendScope::OWNER_CUSTOM tells the system to handle almost everything, so that you do not have to write a new form type for instance. The option 'view' => ['priority' => 199] allows developers to force the ordering of the fields in the view. The higher the value, the higher in the view.","title":"Ordering the fields on the different views (full, create, update)"},{"location":"postgresql/insert-medias/","text":"Insert product medias in the database Data preparation You must prepare your data as a PostgreSQL VALUES query, either built from a CSV input or whatever you will find the most useful. Then paste it as the first sub-query in the following query. Insertion query WITH input_data (sku, filename, mime_type, extension) AS ( VALUES (TEXT 'SKU123', TEXT 'product-image-one.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU124', TEXT 'product-image-two.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU125', TEXT 'product-image-three.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU126', TEXT 'product-image-four.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU127', TEXT 'product-image-five.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU128', TEXT 'product-image-six.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU129', TEXT 'product-image-seven.jpg', TEXT 'image/jpeg', TEXT 'jpg') ), temporary_data AS ( SELECT nextval('oro_attachment_file_id_seq') as attachment_id, nextval('oro_product_image_id_seq') as product_image_id, nextval('oro_product_image_type_id_seq') as product_image_type_main_id, nextval('oro_product_image_type_id_seq') as product_image_type_listing_id, i.filename AS filename, af.original_filename AS existing_filename, i.extension AS extension, i.mime_type AS mime_type, i.filename AS original_filename, NOW() as created_at, NOW() as updated_at, p.id AS product_id, im.image_id, itm.type AS main_type, itl.type AS listing_type, im.id as existing_image_id, af.id AS existing_attachment_id, itm.id AS existing_image_type_main_id, itl.id AS existing_image_type_listing_id FROM input_data AS i INNER JOIN oro_product AS p ON p.sku = i.sku LEFT JOIN oro_product_image AS im ON p.id=im.product_id LEFT JOIN oro_attachment_file as af ON im.image_id=af.id AND af.original_filename!=i.filename LEFT JOIN oro_product_image_type AS itm ON im.id=itm.product_image_id AND itm.type='main' LEFT JOIN oro_product_image_type AS itl ON im.id=itl.product_image_id AND itl.type='listing' ), inserted_attachment AS ( INSERT INTO oro_attachment_file SELECT attachment_id AS id, filename AS filename, extension AS extension, mime_type AS mime_type, NULL AS file_size, original_filename AS original_filename, created_at AS created_at, updated_at AS updated_at, NULL AS owner_user_id, 'Tjs=' AS serialized_data FROM temporary_data AS tl ON CONFLICT DO NOTHING ), inserted_product_image AS ( INSERT INTO oro_product_image SELECT tl.product_image_id AS id, tl.product_id AS product_id, tl.attachment_id AS image_id, NOW() AS updated_at, 'Tjs=' AS serialized_data FROM temporary_data AS tl ), inserted_product_image_main AS ( INSERT INTO oro_product_image_type SELECT tl.product_image_type_main_id AS id, tl.product_image_id AS product_image_id, 'main' AS type FROM temporary_data AS tl WHERE tl.main_type IS NULL ), inserted_product_image_listing AS ( INSERT INTO oro_product_image_type SELECT tl.product_image_type_listing_id AS id, tl.product_image_id AS product_image_id, 'listing' AS type FROM temporary_data AS tl WHERE tl.main_type IS NULL ) SELECT * FROM temporary_data AS t;","title":"Insert product medias in the database"},{"location":"postgresql/insert-medias/#insert-product-medias-in-the-database","text":"","title":"Insert product medias in the database"},{"location":"postgresql/insert-medias/#data-preparation","text":"You must prepare your data as a PostgreSQL VALUES query, either built from a CSV input or whatever you will find the most useful. Then paste it as the first sub-query in the following query.","title":"Data preparation"},{"location":"postgresql/insert-medias/#insertion-query","text":"WITH input_data (sku, filename, mime_type, extension) AS ( VALUES (TEXT 'SKU123', TEXT 'product-image-one.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU124', TEXT 'product-image-two.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU125', TEXT 'product-image-three.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU126', TEXT 'product-image-four.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU127', TEXT 'product-image-five.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU128', TEXT 'product-image-six.jpg', TEXT 'image/jpeg', TEXT 'jpg'), (TEXT 'SKU129', TEXT 'product-image-seven.jpg', TEXT 'image/jpeg', TEXT 'jpg') ), temporary_data AS ( SELECT nextval('oro_attachment_file_id_seq') as attachment_id, nextval('oro_product_image_id_seq') as product_image_id, nextval('oro_product_image_type_id_seq') as product_image_type_main_id, nextval('oro_product_image_type_id_seq') as product_image_type_listing_id, i.filename AS filename, af.original_filename AS existing_filename, i.extension AS extension, i.mime_type AS mime_type, i.filename AS original_filename, NOW() as created_at, NOW() as updated_at, p.id AS product_id, im.image_id, itm.type AS main_type, itl.type AS listing_type, im.id as existing_image_id, af.id AS existing_attachment_id, itm.id AS existing_image_type_main_id, itl.id AS existing_image_type_listing_id FROM input_data AS i INNER JOIN oro_product AS p ON p.sku = i.sku LEFT JOIN oro_product_image AS im ON p.id=im.product_id LEFT JOIN oro_attachment_file as af ON im.image_id=af.id AND af.original_filename!=i.filename LEFT JOIN oro_product_image_type AS itm ON im.id=itm.product_image_id AND itm.type='main' LEFT JOIN oro_product_image_type AS itl ON im.id=itl.product_image_id AND itl.type='listing' ), inserted_attachment AS ( INSERT INTO oro_attachment_file SELECT attachment_id AS id, filename AS filename, extension AS extension, mime_type AS mime_type, NULL AS file_size, original_filename AS original_filename, created_at AS created_at, updated_at AS updated_at, NULL AS owner_user_id, 'Tjs=' AS serialized_data FROM temporary_data AS tl ON CONFLICT DO NOTHING ), inserted_product_image AS ( INSERT INTO oro_product_image SELECT tl.product_image_id AS id, tl.product_id AS product_id, tl.attachment_id AS image_id, NOW() AS updated_at, 'Tjs=' AS serialized_data FROM temporary_data AS tl ), inserted_product_image_main AS ( INSERT INTO oro_product_image_type SELECT tl.product_image_type_main_id AS id, tl.product_image_id AS product_image_id, 'main' AS type FROM temporary_data AS tl WHERE tl.main_type IS NULL ), inserted_product_image_listing AS ( INSERT INTO oro_product_image_type SELECT tl.product_image_type_listing_id AS id, tl.product_image_id AS product_image_id, 'listing' AS type FROM temporary_data AS tl WHERE tl.main_type IS NULL ) SELECT * FROM temporary_data AS t;","title":"Insertion query"},{"location":"postgresql/sql-tips/","text":"SQL tips Oro Pour conna\u00eetre les tables de plus de 100mb : SELECT *, pg_size_pretty(total_bytes) AS total, pg_size_pretty(index_bytes) AS INDEX, pg_size_pretty(toast_bytes) AS toast, pg_size_pretty(table_bytes) AS TABLE FROM ( SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes FROM ( SELECT c.oid, nspname AS table_schema, relname AS TABLE_NAME, c.reltuples AS row_estimate, pg_total_relation_size(c.oid) AS total_bytes, pg_indexes_size(c.oid) AS index_bytes, pg_total_relation_size(reltoastrelid) AS toast_bytes FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = c.relnamespace WHERE relkind = 'r' AND nspname='public' ) a ) a WHERE total_bytes > 100000000 ORDER BY total_bytes DESC;","title":"Pour identifier les tables lourdes"},{"location":"postgresql/sql-tips/#sql-tips-oro","text":"Pour conna\u00eetre les tables de plus de 100mb : SELECT *, pg_size_pretty(total_bytes) AS total, pg_size_pretty(index_bytes) AS INDEX, pg_size_pretty(toast_bytes) AS toast, pg_size_pretty(table_bytes) AS TABLE FROM ( SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes FROM ( SELECT c.oid, nspname AS table_schema, relname AS TABLE_NAME, c.reltuples AS row_estimate, pg_total_relation_size(c.oid) AS total_bytes, pg_indexes_size(c.oid) AS index_bytes, pg_total_relation_size(reltoastrelid) AS toast_bytes FROM pg_class c LEFT JOIN pg_namespace n ON n.oid = c.relnamespace WHERE relkind = 'r' AND nspname='public' ) a ) a WHERE total_bytes > 100000000 ORDER BY total_bytes DESC;","title":"SQL tips Oro"},{"location":"tests/behat-autoloading/","text":"La classe OroTestFrameworkExtension est responsable de la g\u00e9n\u00e9ration des suites de test. Lors de l'initialisation, l'extension cr\u00e9e une suite de tests avec un nom de bundle si un r\u00e9pertoire Tests/Behat/Features existe dans un bundle. Ainsi, si le bundle n'a pas de r\u00e9pertoire Features - aucune suite de tests ne sera cr\u00e9\u00e9e ce bundle. Si vous avez besoin de certaines \u00e9tapes de fonctionnalit\u00e9 sp\u00e9cifiques pour votre bundle, cr\u00e9ez la classe AcmeDemoBundle\\Tests\\Behat\\Context\\FeatureContext. Ce contexte est ajout\u00e9 \u00e0 la suite avec les contextes courants.La liste compl\u00e8te du contexte commun est configur\u00e9e dans le fichier de configuration behat sous la cl\u00e9 shared_contexts . Vous pouvez configurer manuellement la suite de tests pour un bundle dans la configuration de l'application behat: default: &default suites: AcmeDemoBundle: type: symfony_bundle bundle: AcmeDemoBundle contexts: - Oro\\Bundle\\TestFrameworkBundle\\Tests\\Behat\\Context\\OroMainContext - OroDataGridBundle::GridContext - AcmeDemoBundle::FeatureContext paths: - 'vendor/Acme/DemoBundle/Tests/Behat/Features' ou dans une configuration de bundle behat {BundleName}/Tests/Behat/behat.yml : oro_behat_extension: suites: AcmeDemoBundle: contexts: - Oro\\Bundle\\TestFrameworkBundle\\Tests\\Behat\\Context\\OroMainContext - OroDataGridBundle::GridContext - AcmeDemoBundle::FeatureContext paths: - '@AcmeDemoBundle/Tests/Behat/Features' Les suites de test configur\u00e9es manuellement ne sont pas charg\u00e9es automatiquement par l'extension.","title":"Behat autoloading"},{"location":"tests/behat-configuration/","text":"Configuration de l'application : Utilisez la configuration par d\u00e9faut de l'application install\u00e9e en mode production. Si aucun serveur de messagerie n'est configur\u00e9 localement, d\u00e9finissez le param\u00e8tre mailer_transport dans parameters.yml sur null. Configuration Behat La configuration de base se trouve dans behat.yml.dist. Chaque application poss\u00e8de son propre fichier behat.yml.dist \u00e0 la racine du r\u00e9pertoire de l'application. Cr\u00e9ez votre behat.yml (il est ignor\u00e9 par git automatiquement et n'est jamais valid\u00e9 dans le r\u00e9f\u00e9rentiel distant), importez la configuration de base et modifiez-la pour l'adapter \u00e0 votre environnement: configuration en local, sans docker yaml imports: - ./behat.yml.dist default: &default extensions: &default_extensions Behat\\MinkExtension: browser_name: chrome base_url: \"http://localhost:8010\" configuration avec la stack docker kiboko imports: - ./behat.yml.dist default: &default extensions: &default_extensions Behat\\MinkExtension: browser_name: chrome base_url: 'http://http' default_session: 'first_session' sessions: second_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: browser: chrome extra_capabilities: browser: chrome chromeOptions: w3c: false first_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: browser: chrome extra_capabilities: browser: chrome chromeOptions: w3c: false system_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: browser: chrome extra_capabilities: browser: chrome chromeOptions: w3c: false 320_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: extra_capabilities: chromeOptions: w3c: false 640_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: extra_capabilities: chromeOptions: w3c: false !!! => Configurer votre parameters.yml avec le search engine en orm et dbal pour les messages Installation Installation des d\u00e9pendances de d\u00e9veloppement : Si vous avez install\u00e9 des d\u00e9pendances avec le param\u00e8tre --no-dev plus t\u00f4t, supprimez le fichier composer.lock de la racine du r\u00e9pertoire de l'application. Installez les d\u00e9pendances dev \u00e0 l'aide de la commande suivante composer install Etat de l'application initiale Dans Oro, l'\u00e9tat initial est celui lorsque l'application est install\u00e9 sans donn\u00e9es de d\u00e9monstration. Les sc\u00e9narios qui testent des fonctionnalit\u00e9s doivent s'appuyer sur cet \u00e9tat et doivent cr\u00e9er toutes les donn\u00e9es n\u00e9cessaires \u00e0 des v\u00e9rifications suppl\u00e9mentaires. Les donn\u00e9es peuvent \u00eatre cr\u00e9\u00e9es par les \u00e9tapes du sc\u00e9nario ou comme montages. Installez l'application en anglais, sans donn\u00e9es de d\u00e9monstration en mode production, sans rabbit et elastic \u00e0 l'aide de la commande suivante: bin/console oro:install --drop-database --user-name=admin --user-email=admin@example.com \\ --application-url=http://localhost:8010 --user-firstname=John --user-lastname=Doe \\ --user-password=admin --organization-name=ORO --env=prod --sample-data=n --timeout=3000 \\ --formatting-code=en --language=en Installation des outils de test en local, sans la stack docker : Pour ex\u00e9cuter des sc\u00e9narios qui utilisent les fonctionnalit\u00e9s de l'application Oro, ex\u00e9cutez le navigateur WebKit (\u00e0 l'aide de ChromeDriver). Pour installer ChromeDriver, ex\u00e9cutez les commandes suivantes: LINUX : CHROME_DRIVER_VERSION=$(curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE) mkdir -p \"$HOME/chrome\" || true wget \"http://chromedriver.storage.googleapis.com/${CHROME_DRIVER_VERSION}/chromedriver_linux64.zip\" -O \"$HOME/chrome/chromedriver_linux64_${CHROME_DRIVER_VERSION}.zip\" unzip \"$HOME/chrome/chromedriver_linux64_${CHROME_DRIVER_VERSION}.zip\" -d \"$HOME/chrome\" sudo ln -s \"$HOME/chrome/chromedriver\" /usr/local/bin/chromedriver MAC : brew cask install chromedriver Installation des outils de test avec la stack docker : version: '2.2' services: mailcatcher: image: schickling/mailcatcher:latest ports: - ${MAILCATCHER_PORT}:1080 sql: image: postgres:9.6-alpine ports: - ${SQL_PORT}:5432 environment: - POSTGRES_USER - POSTGRES_DB - POSTGRES_PASSWORD - POSTGRES_ROOT_PASSWORD volumes: - ./.docker/postgres@9.6/sql/uuid-ossp.sql:/docker-entrypoint-initdb.d/00-uuid-ossp.sql:ro - ./.docker/postgres@9.6/custom-sql/:/docker-entrypoint-initdb.d/custom-sql/ - database:/var/lib/postgresql/data restart: on-failure http: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/reverse-proxy.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:ro - assets:/var/www/html/public/bundles:ro restart: on-failure ports: - ${HTTP_PORT}:80 depends_on: - http-worker-prod - http-worker-dev - http-worker-xdebug http-worker-prod: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/vhost-prod.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:delegated - assets:/var/www/html/public/bundles:delegated restart: on-failure depends_on: - fpm http-worker-dev: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/vhost-dev.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:ro - assets:/var/www/html/public/bundles:ro restart: on-failure depends_on: - fpm http-worker-xdebug: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/vhost-xdebug.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:ro - assets:/var/www/html/public/bundles:ro restart: on-failure depends_on: - fpm-xdebug fpm: image: kiboko/php:7.2-fpm-blackfire-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles environment: - \"I_AM_DEVELOPER_DISABLE_INDEX_IP_CHECK=\" - BLACKFIRE_CLIENT_ID - BLACKFIRE_CLIENT_TOKEN restart: on-failure fpm-xdebug: image: kiboko/php:7.2-fpm-xdebug-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles environment: - \"I_AM_DEVELOPER_DISABLE_INDEX_IP_CHECK=\" restart: on-failure blackfire: image: blackfire/blackfire environment: - BLACKFIRE_SERVER_ID - BLACKFIRE_SERVER_TOKEN sh: build: context: .docker/sh@7.2/ user: docker:docker volumes: - $HOME/.ssh:/opt/docker/.ssh:cached - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles - composer:/opt/docker/.composer/:cached environment: - COMPOSER_AUTH - COMPOSER_PROCESS_TIMEOUT - BLACKFIRE_CLIENT_ID - BLACKFIRE_CLIENT_TOKEN - HOME=/var/www/html command: [ \"sleep\", \"31536000\" ] restart: \"always\" sh-xdebug: image: kiboko/php:7.2-cli-xdebug-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - $HOME/.ssh:/opt/docker/.ssh:cached - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles - composer:/opt/docker/.composer/ environment: - COMPOSER_AUTH - COMPOSER_PROCESS_TIMEOUT command: [ \"sleep\", \"31536000\" ] restart: \"always\" mq: image: kiboko/php:7.2-cli-blackfire-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles command: [ \"bin/console\", \"oro:message-queue:consume\", \"--env=prod\", \"-vv\" ] restart: \"always\" ws: image: kiboko/php:7.2-cli-blackfire-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles command: [ \"bin/console\", \"gos:websocket:server\", \"--env=prod\", \"-vv\" ] ports: - ${WEBSOCKET_PORT}:8080 restart: \"always\" elasticsearch: image: 'docker.elastic.co/elasticsearch/elasticsearch-oss:6.5.4' environment: - cluster.name=docker-cluster - bootstrap.memory_lock=true - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" - discovery.type=single-node - http.port=9200 - http.cors.allow-origin=http://localhost:${DEJAVU_PORT},http://127.0.0.1:${DEJAVU_PORT},http://192.168.64.4:${DEJAVU_PORT},http://dejavu:${DEJAVU_PORT},http://host.docker.internal:${DEJAVU_PORT} - http.cors.enabled=true - http.cors.allow-headers=X-Requested-With,X-Auth-Token,Content-Type,Content-Length,Authorization - http.cors.allow-credentials=true ports: - ${ELASTICSEARCH_PORT}:9200 volumes: - elasticsearch:/usr/share/elasticsearch/data - ./.docker/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml restart: on-failure dejavu: image: appbaseio/dejavu ports: - ${DEJAVU_PORT}:1358 amqp: build: context: .docker/rabbitmq@3.6 ports: - ${RABBITMQ_AMQP_PORT}:5672 - ${RABBITMQ_MANAGER_PORT}:15672 environment: - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER} - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD} restart: on-failure redis: build: context: .docker/redis@5/ restart: on-failure ports: - ${REDIS_PORT}:6379 chrome: image: selenium/node-chrome:3.141.59-oxygen volumes: - /dev/shm:/dev/shm depends_on: - hub environment: HUB_HOST: hub firefox: image: selenium/node-firefox:3.141.59-20200525 volumes: - /dev/shm:/dev/shm depends_on: - hub environment: HUB_HOST: hub opera: image: selenium/node-opera:3.141.59-20200525 volumes: - /dev/shm:/dev/shm depends_on: - hub environment: HUB_HOST: hub hub: image: selenium/hub:3.141.59-20200525 ports: - ${HUB_PORT}::4444 volumes: database: driver: local elasticsearch: driver: local composer: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=2048m,uid=1001,gid=1002\" assets: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=2048m,uid=1001,gid=1002\" cache: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=2048m,uid=1001,gid=1002\" Lancement des outils de tests en local, sans docker Conditions pr\u00e9alables Ex\u00e9cutez ChromeDriver: chromedriver --url-base=wd/hub --port=4444 > /tmp/driver.log 2>&1 Pour ex\u00e9cuter ChromeDriver en arri\u00e8re-plan, ajoutez le symbole esperluette (&) \u00e0 la fin de la ligne, comme dans les exemples suivants: chromedriver --url-base=wd/hub --port=4444 > /tmp/driver.log 2>&1 & Lancer un serveur sur le port sp\u00e9cifi\u00e9 pour l'installation (ici 8010 ), avec apache, nginx, ou juste le serveur symfony de base Execution des tests Avant de commencer, il est fortement recommand\u00e9 de vous familiariser avec les arguments et les options de Behat. Ex\u00e9cutez bin/behat --help pour une description d\u00e9taill\u00e9e. Lorsque l'application Oro est install\u00e9e sans donn\u00e9es de d\u00e9monstration et est en cours d'ex\u00e9cution, et que ChromeDriver est en cours d'ex\u00e9cution, vous pouvez commencer \u00e0 ex\u00e9cuter les tests behat par fonctionnalit\u00e9 \u00e0 partir de la racine de l'application. Vous pouvez utiliser l'une des commandes suivantes. Ex\u00e9cutez le sc\u00e9nario de test des fonctionnalit\u00e9s: bin/behat vendor/oro/platform/src/Oro/Bundle/UserBundle/Tests/Behat/Features/login.feature -vvv Aper\u00e7u de toutes les \u00e9tapes de fonctionnalit\u00e9 disponibles: bin/behat -dl -s OroUserBundle Voir les \u00e9tapes avec une description compl\u00e8te et des exemples: bin/behat -di -s OroUserBundle Chaque bundle a sa suite de tests d\u00e9di\u00e9e qui peut \u00eatre ex\u00e9cut\u00e9e s\u00e9par\u00e9ment: bin/behat -s OroUserBundle","title":"Behat configuration"},{"location":"tests/behat-configuration/#configuration-en-local-sans-docker","text":"yaml imports: - ./behat.yml.dist default: &default extensions: &default_extensions Behat\\MinkExtension: browser_name: chrome base_url: \"http://localhost:8010\"","title":"configuration en local, sans docker"},{"location":"tests/behat-configuration/#configuration-avec-la-stack-docker-kiboko","text":"imports: - ./behat.yml.dist default: &default extensions: &default_extensions Behat\\MinkExtension: browser_name: chrome base_url: 'http://http' default_session: 'first_session' sessions: second_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: browser: chrome extra_capabilities: browser: chrome chromeOptions: w3c: false first_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: browser: chrome extra_capabilities: browser: chrome chromeOptions: w3c: false system_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: browser: chrome extra_capabilities: browser: chrome chromeOptions: w3c: false 320_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: extra_capabilities: chromeOptions: w3c: false 640_session: oroSelenium2: wd_host: 'http://localhost:4444/wd/hub' capabilities: extra_capabilities: chromeOptions: w3c: false !!! => Configurer votre parameters.yml avec le search engine en orm et dbal pour les messages","title":"configuration avec la stack docker kiboko"},{"location":"tests/behat-configuration/#installation","text":"","title":"Installation"},{"location":"tests/behat-configuration/#installation-des-dependances-de-developpement","text":"Si vous avez install\u00e9 des d\u00e9pendances avec le param\u00e8tre --no-dev plus t\u00f4t, supprimez le fichier composer.lock de la racine du r\u00e9pertoire de l'application. Installez les d\u00e9pendances dev \u00e0 l'aide de la commande suivante composer install","title":"Installation des d\u00e9pendances de d\u00e9veloppement :"},{"location":"tests/behat-configuration/#etat-de-lapplication-initiale","text":"Dans Oro, l'\u00e9tat initial est celui lorsque l'application est install\u00e9 sans donn\u00e9es de d\u00e9monstration. Les sc\u00e9narios qui testent des fonctionnalit\u00e9s doivent s'appuyer sur cet \u00e9tat et doivent cr\u00e9er toutes les donn\u00e9es n\u00e9cessaires \u00e0 des v\u00e9rifications suppl\u00e9mentaires. Les donn\u00e9es peuvent \u00eatre cr\u00e9\u00e9es par les \u00e9tapes du sc\u00e9nario ou comme montages. Installez l'application en anglais, sans donn\u00e9es de d\u00e9monstration en mode production, sans rabbit et elastic \u00e0 l'aide de la commande suivante: bin/console oro:install --drop-database --user-name=admin --user-email=admin@example.com \\ --application-url=http://localhost:8010 --user-firstname=John --user-lastname=Doe \\ --user-password=admin --organization-name=ORO --env=prod --sample-data=n --timeout=3000 \\ --formatting-code=en --language=en","title":"Etat de l'application initiale"},{"location":"tests/behat-configuration/#installation-des-outils-de-test-en-local-sans-la-stack-docker","text":"Pour ex\u00e9cuter des sc\u00e9narios qui utilisent les fonctionnalit\u00e9s de l'application Oro, ex\u00e9cutez le navigateur WebKit (\u00e0 l'aide de ChromeDriver). Pour installer ChromeDriver, ex\u00e9cutez les commandes suivantes: LINUX : CHROME_DRIVER_VERSION=$(curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE) mkdir -p \"$HOME/chrome\" || true wget \"http://chromedriver.storage.googleapis.com/${CHROME_DRIVER_VERSION}/chromedriver_linux64.zip\" -O \"$HOME/chrome/chromedriver_linux64_${CHROME_DRIVER_VERSION}.zip\" unzip \"$HOME/chrome/chromedriver_linux64_${CHROME_DRIVER_VERSION}.zip\" -d \"$HOME/chrome\" sudo ln -s \"$HOME/chrome/chromedriver\" /usr/local/bin/chromedriver MAC : brew cask install chromedriver","title":"Installation des outils de test en local, sans la stack docker :"},{"location":"tests/behat-configuration/#installation-des-outils-de-test-avec-la-stack-docker","text":"version: '2.2' services: mailcatcher: image: schickling/mailcatcher:latest ports: - ${MAILCATCHER_PORT}:1080 sql: image: postgres:9.6-alpine ports: - ${SQL_PORT}:5432 environment: - POSTGRES_USER - POSTGRES_DB - POSTGRES_PASSWORD - POSTGRES_ROOT_PASSWORD volumes: - ./.docker/postgres@9.6/sql/uuid-ossp.sql:/docker-entrypoint-initdb.d/00-uuid-ossp.sql:ro - ./.docker/postgres@9.6/custom-sql/:/docker-entrypoint-initdb.d/custom-sql/ - database:/var/lib/postgresql/data restart: on-failure http: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/reverse-proxy.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:ro - assets:/var/www/html/public/bundles:ro restart: on-failure ports: - ${HTTP_PORT}:80 depends_on: - http-worker-prod - http-worker-dev - http-worker-xdebug http-worker-prod: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/vhost-prod.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:delegated - assets:/var/www/html/public/bundles:delegated restart: on-failure depends_on: - fpm http-worker-dev: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/vhost-dev.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:ro - assets:/var/www/html/public/bundles:ro restart: on-failure depends_on: - fpm http-worker-xdebug: image: nginx:alpine volumes: - ./.docker/nginx@1.15/config/options.conf:/etc/nginx/conf.d/000-options.conf - ./.docker/nginx@1.15/config/vhost-xdebug.conf:/etc/nginx/conf.d/default.conf - ./:/var/www/html - cache:/var/www/html/var/cache:ro - assets:/var/www/html/public/bundles:ro restart: on-failure depends_on: - fpm-xdebug fpm: image: kiboko/php:7.2-fpm-blackfire-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles environment: - \"I_AM_DEVELOPER_DISABLE_INDEX_IP_CHECK=\" - BLACKFIRE_CLIENT_ID - BLACKFIRE_CLIENT_TOKEN restart: on-failure fpm-xdebug: image: kiboko/php:7.2-fpm-xdebug-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles environment: - \"I_AM_DEVELOPER_DISABLE_INDEX_IP_CHECK=\" restart: on-failure blackfire: image: blackfire/blackfire environment: - BLACKFIRE_SERVER_ID - BLACKFIRE_SERVER_TOKEN sh: build: context: .docker/sh@7.2/ user: docker:docker volumes: - $HOME/.ssh:/opt/docker/.ssh:cached - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles - composer:/opt/docker/.composer/:cached environment: - COMPOSER_AUTH - COMPOSER_PROCESS_TIMEOUT - BLACKFIRE_CLIENT_ID - BLACKFIRE_CLIENT_TOKEN - HOME=/var/www/html command: [ \"sleep\", \"31536000\" ] restart: \"always\" sh-xdebug: image: kiboko/php:7.2-cli-xdebug-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - $HOME/.ssh:/opt/docker/.ssh:cached - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles - composer:/opt/docker/.composer/ environment: - COMPOSER_AUTH - COMPOSER_PROCESS_TIMEOUT command: [ \"sleep\", \"31536000\" ] restart: \"always\" mq: image: kiboko/php:7.2-cli-blackfire-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles command: [ \"bin/console\", \"oro:message-queue:consume\", \"--env=prod\", \"-vv\" ] restart: \"always\" ws: image: kiboko/php:7.2-cli-blackfire-orocommerce-ee-3.1-postgresql user: docker:docker volumes: - ./:/var/www/html - cache:/var/www/html/var/cache - assets:/var/www/html/public/bundles command: [ \"bin/console\", \"gos:websocket:server\", \"--env=prod\", \"-vv\" ] ports: - ${WEBSOCKET_PORT}:8080 restart: \"always\" elasticsearch: image: 'docker.elastic.co/elasticsearch/elasticsearch-oss:6.5.4' environment: - cluster.name=docker-cluster - bootstrap.memory_lock=true - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" - discovery.type=single-node - http.port=9200 - http.cors.allow-origin=http://localhost:${DEJAVU_PORT},http://127.0.0.1:${DEJAVU_PORT},http://192.168.64.4:${DEJAVU_PORT},http://dejavu:${DEJAVU_PORT},http://host.docker.internal:${DEJAVU_PORT} - http.cors.enabled=true - http.cors.allow-headers=X-Requested-With,X-Auth-Token,Content-Type,Content-Length,Authorization - http.cors.allow-credentials=true ports: - ${ELASTICSEARCH_PORT}:9200 volumes: - elasticsearch:/usr/share/elasticsearch/data - ./.docker/elasticsearch/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml restart: on-failure dejavu: image: appbaseio/dejavu ports: - ${DEJAVU_PORT}:1358 amqp: build: context: .docker/rabbitmq@3.6 ports: - ${RABBITMQ_AMQP_PORT}:5672 - ${RABBITMQ_MANAGER_PORT}:15672 environment: - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER} - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD} restart: on-failure redis: build: context: .docker/redis@5/ restart: on-failure ports: - ${REDIS_PORT}:6379 chrome: image: selenium/node-chrome:3.141.59-oxygen volumes: - /dev/shm:/dev/shm depends_on: - hub environment: HUB_HOST: hub firefox: image: selenium/node-firefox:3.141.59-20200525 volumes: - /dev/shm:/dev/shm depends_on: - hub environment: HUB_HOST: hub opera: image: selenium/node-opera:3.141.59-20200525 volumes: - /dev/shm:/dev/shm depends_on: - hub environment: HUB_HOST: hub hub: image: selenium/hub:3.141.59-20200525 ports: - ${HUB_PORT}::4444 volumes: database: driver: local elasticsearch: driver: local composer: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=2048m,uid=1001,gid=1002\" assets: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=2048m,uid=1001,gid=1002\" cache: driver: local driver_opts: type: tmpfs device: tmpfs o: \"size=2048m,uid=1001,gid=1002\"","title":"Installation des outils de test avec la stack docker :"},{"location":"tests/behat-configuration/#lancement-des-outils-de-tests-en-local-sans-docker","text":"Conditions pr\u00e9alables Ex\u00e9cutez ChromeDriver: chromedriver --url-base=wd/hub --port=4444 > /tmp/driver.log 2>&1 Pour ex\u00e9cuter ChromeDriver en arri\u00e8re-plan, ajoutez le symbole esperluette (&) \u00e0 la fin de la ligne, comme dans les exemples suivants: chromedriver --url-base=wd/hub --port=4444 > /tmp/driver.log 2>&1 & Lancer un serveur sur le port sp\u00e9cifi\u00e9 pour l'installation (ici 8010 ), avec apache, nginx, ou juste le serveur symfony de base","title":"Lancement des outils de tests en local, sans docker"},{"location":"tests/behat-configuration/#execution-des-tests","text":"Avant de commencer, il est fortement recommand\u00e9 de vous familiariser avec les arguments et les options de Behat. Ex\u00e9cutez bin/behat --help pour une description d\u00e9taill\u00e9e. Lorsque l'application Oro est install\u00e9e sans donn\u00e9es de d\u00e9monstration et est en cours d'ex\u00e9cution, et que ChromeDriver est en cours d'ex\u00e9cution, vous pouvez commencer \u00e0 ex\u00e9cuter les tests behat par fonctionnalit\u00e9 \u00e0 partir de la racine de l'application. Vous pouvez utiliser l'une des commandes suivantes. Ex\u00e9cutez le sc\u00e9nario de test des fonctionnalit\u00e9s: bin/behat vendor/oro/platform/src/Oro/Bundle/UserBundle/Tests/Behat/Features/login.feature -vvv Aper\u00e7u de toutes les \u00e9tapes de fonctionnalit\u00e9 disponibles: bin/behat -dl -s OroUserBundle Voir les \u00e9tapes avec une description compl\u00e8te et des exemples: bin/behat -di -s OroUserBundle Chaque bundle a sa suite de tests d\u00e9di\u00e9e qui peut \u00eatre ex\u00e9cut\u00e9e s\u00e9par\u00e9ment: bin/behat -s OroUserBundle","title":"Execution des tests"},{"location":"tests/behat-conventions/","text":"Conventions Utilisez le mapping de formulaire au lieu de s\u00e9lecteurs dans vos sc\u00e9narios pour les garder clairs et compr\u00e9hensibles pour les personnes du monde technique et non technique. Example Ne pas: I fill in \"oro_workflow_definition_form[label]\" with \"User Workflow Test\" I fill in \"oro_workflow_definition_form[related_entity]\" with \"User\" Mais plutot : And I fill \"Workflow Edit Form\" with: | Name | User Workflow Test | | Related Entity | User | avec la description des \u00e9l\u00e9ments ind\u00e9pendament : Workflow Edit Form: selector: 'form[name=\"oro_workflow_definition_form\"]' class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: mapping: Name: 'oro_workflow_definition_form[label]' Related Entity: 'oro_workflow_definition_form[related_entity]' Utilisez des menu et des liens pour obtenir les bonnes pages au lieu de l'URL de la page directe Faire : And I open User Index page Et non pas : And I go to \"/users\" \u00c9vitez la redondance des sc\u00e9narios (par exemple, en r\u00e9p\u00e9tant la m\u00eame s\u00e9quence d'\u00e9tapes, comme la connexion, dans plusieurs sc\u00e9narios). Couvrez la fonctionnalit\u00e9 avec les sc\u00e9narios s\u00e9quentiels o\u00f9 chaque sc\u00e9nario suivant r\u00e9utilise les r\u00e9sultats (les \u00e9tats et les donn\u00e9es) pr\u00e9par\u00e9s par leurs pr\u00e9d\u00e9cesseurs. Cette m\u00e9thode a \u00e9t\u00e9 choisie en raison des avantages suivants: Ex\u00e9cution de sc\u00e9nario plus rapide gr\u00e2ce \u00e0 la session utilisateur partag\u00e9e et \u00e0 la pr\u00e9paration intelligente des donn\u00e9es. L'action de connexion dans le sc\u00e9nario initial ouvre la session qui est r\u00e9utilisable par les sc\u00e9narios suivants. Les sc\u00e9narios pr\u00e9liminaires (par exemple, cr\u00e9er) pr\u00e9parent des donn\u00e9es pour les sc\u00e9narios suivants (par exemple, supprimer). L'isolation au niveau des fonctionnalit\u00e9s augmente la vitesse d'ex\u00e9cution, en particulier dans les environnements de test lents. Actions de d\u00e9veloppement de routine minimis\u00e9es (par exemple, vous n'avez pas \u00e0 charger les fixtures pour chaque sc\u00e9nario; au lieu de cela, vous r\u00e9utilisez les r\u00e9sultats disponibles des sc\u00e9narios pr\u00e9c\u00e9dents). Gestion ais\u00e9e des \u00e9tats d'application difficiles \u00e0 \u00e9muler uniquement avec des fixtures (par exemple, lors de l'ajout de nouveaux champs d'entit\u00e9 dans l'interface utilisateur). En couplant les sc\u00e9narios, la facilit\u00e9 de d\u00e9bogage et de localisation des bogues est r\u00e9duite. Il est difficile de d\u00e9boguer les fonctionnalit\u00e9s de l'interface utilisateur et les sc\u00e9narios qui se produisent apr\u00e8s plusieurs sc\u00e9narios pr\u00e9liminaires. Plus la ligne est longue, plus il est difficile d'isoler le probl\u00e8me. Utiliser des fixtures yml s\u00e9mantiques Utilisez uniquement les entit\u00e9s qui se trouvent dans le bundle que vous testez. Toutes les autres entit\u00e9s doivent \u00eatre incluses via une importation. Voir les Fixtures Alice pour plus d'informations. Nommer les \u00e9l\u00e9ments dans le style camelCase sans espaces Vous pouvez toujours vous y r\u00e9f\u00e9rer en utilisant le style camelCase avec des espaces dans les sc\u00e9narios behat. Par exemple, un \u00e9l\u00e9ment nomm\u00e9 OroProductForm peut \u00eatre mentionn\u00e9 dans l'\u00e9tape du sc\u00e9nario comme \u00abOro Product From\u00bb: Use Scenario: Feature Background instead of the Background step","title":"Behat conventions"},{"location":"tests/behat-conventions/#conventions","text":"Utilisez le mapping de formulaire au lieu de s\u00e9lecteurs dans vos sc\u00e9narios pour les garder clairs et compr\u00e9hensibles pour les personnes du monde technique et non technique.","title":"Conventions"},{"location":"tests/behat-conventions/#example","text":"Ne pas: I fill in \"oro_workflow_definition_form[label]\" with \"User Workflow Test\" I fill in \"oro_workflow_definition_form[related_entity]\" with \"User\" Mais plutot : And I fill \"Workflow Edit Form\" with: | Name | User Workflow Test | | Related Entity | User | avec la description des \u00e9l\u00e9ments ind\u00e9pendament : Workflow Edit Form: selector: 'form[name=\"oro_workflow_definition_form\"]' class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: mapping: Name: 'oro_workflow_definition_form[label]' Related Entity: 'oro_workflow_definition_form[related_entity]' Utilisez des menu et des liens pour obtenir les bonnes pages au lieu de l'URL de la page directe Faire : And I open User Index page Et non pas : And I go to \"/users\" \u00c9vitez la redondance des sc\u00e9narios (par exemple, en r\u00e9p\u00e9tant la m\u00eame s\u00e9quence d'\u00e9tapes, comme la connexion, dans plusieurs sc\u00e9narios). Couvrez la fonctionnalit\u00e9 avec les sc\u00e9narios s\u00e9quentiels o\u00f9 chaque sc\u00e9nario suivant r\u00e9utilise les r\u00e9sultats (les \u00e9tats et les donn\u00e9es) pr\u00e9par\u00e9s par leurs pr\u00e9d\u00e9cesseurs. Cette m\u00e9thode a \u00e9t\u00e9 choisie en raison des avantages suivants: Ex\u00e9cution de sc\u00e9nario plus rapide gr\u00e2ce \u00e0 la session utilisateur partag\u00e9e et \u00e0 la pr\u00e9paration intelligente des donn\u00e9es. L'action de connexion dans le sc\u00e9nario initial ouvre la session qui est r\u00e9utilisable par les sc\u00e9narios suivants. Les sc\u00e9narios pr\u00e9liminaires (par exemple, cr\u00e9er) pr\u00e9parent des donn\u00e9es pour les sc\u00e9narios suivants (par exemple, supprimer). L'isolation au niveau des fonctionnalit\u00e9s augmente la vitesse d'ex\u00e9cution, en particulier dans les environnements de test lents. Actions de d\u00e9veloppement de routine minimis\u00e9es (par exemple, vous n'avez pas \u00e0 charger les fixtures pour chaque sc\u00e9nario; au lieu de cela, vous r\u00e9utilisez les r\u00e9sultats disponibles des sc\u00e9narios pr\u00e9c\u00e9dents). Gestion ais\u00e9e des \u00e9tats d'application difficiles \u00e0 \u00e9muler uniquement avec des fixtures (par exemple, lors de l'ajout de nouveaux champs d'entit\u00e9 dans l'interface utilisateur). En couplant les sc\u00e9narios, la facilit\u00e9 de d\u00e9bogage et de localisation des bogues est r\u00e9duite. Il est difficile de d\u00e9boguer les fonctionnalit\u00e9s de l'interface utilisateur et les sc\u00e9narios qui se produisent apr\u00e8s plusieurs sc\u00e9narios pr\u00e9liminaires. Plus la ligne est longue, plus il est difficile d'isoler le probl\u00e8me. Utiliser des fixtures yml s\u00e9mantiques Utilisez uniquement les entit\u00e9s qui se trouvent dans le bundle que vous testez. Toutes les autres entit\u00e9s doivent \u00eatre incluses via une importation. Voir les Fixtures Alice pour plus d'informations. Nommer les \u00e9l\u00e9ments dans le style camelCase sans espaces Vous pouvez toujours vous y r\u00e9f\u00e9rer en utilisant le style camelCase avec des espaces dans les sc\u00e9narios behat. Par exemple, un \u00e9l\u00e9ment nomm\u00e9 OroProductForm peut \u00eatre mentionn\u00e9 dans l'\u00e9tape du sc\u00e9nario comme \u00abOro Product From\u00bb: Use Scenario: Feature Background instead of the Background step","title":"Example"},{"location":"tests/behat-elements-form/","text":"Elements est une couche de service dans les tests behat. Ils enveloppent la logique m\u00e9tier complexe. Prenez une minute pour lire la base des NodeElement Mink Il y a de nombreuses m\u00e9thodes publiques; certains d'entre eux ne s'appliquent qu'\u00e0 certains \u00e9l\u00e9ments. Chaque test Bundle peut contenir un nombre particulier d'\u00e9l\u00e9ments. Tous les \u00e9l\u00e9ments doivent \u00eatre d\u00e9crits dans {BundleName} {BundleName}/Tests/Behat/behat.yml de la mani\u00e8re suivante: oro_behat_extension: elements: Login: selector: '#login-form' class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: mapping: Username: '_username' Password: '_password' ou : Login est un nom d'\u00e9l\u00e9ment qui DOIT \u00eatre unique. L'\u00e9l\u00e9ment peut \u00eatre cr\u00e9\u00e9 dans un contexte par OroElementFactory par son nom: $this->elementFactory->createElement('Login'); selector` d\u00e9finit comment le driver Web doit trouver l'\u00e9l\u00e9ment sur la page. Par d\u00e9faut, lorsque le type de s\u00e9lecteur n'est pas sp\u00e9cifi\u00e9, le s\u00e9lecteur css est utilis\u00e9. Le s\u00e9lecteur XPath est \u00e9galement pris en charge et peut \u00eatre fourni avec la configuration suivante: selector: type: xpath locator: //span[id='mySpan']/ancestor::form/ Le namespace de l'\u00e9l\u00e9ment (doit \u00eatre \u00e9tendu \u00e0 partir de Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Element ). Lorsqu'elle est omise, la classe Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Element` est utilis\u00e9e par d\u00e9faut. options est un tableau d'options suppl\u00e9mentaires stock\u00e9es dans la propri\u00e9t\u00e9 options de la classe Element. Il est fortement recommand\u00e9 de fournir une classe avec des options de mappage pour les \u00e9l\u00e9ments de formulaire, car cela augmente la vitesse de test et garantit un mappage de champ plus pr\u00e9cis. Mappage des champs de formulaire Par d\u00e9faut, les tests utilisent le s\u00e9lecteur de champ nomm\u00e9 pour mapper les champs du formulaire. Le s\u00e9lecteur de nom de champ a recherch\u00e9 le champ par son identifiant, son nom, son label ou son placeholder. Vous \u00eates libre d'utiliser n'importe quel s\u00e9lecteur pour mapper des champs de formulaire ou encapsuler un \u00e9l\u00e9ment dans l'\u00e9l\u00e9ment behat particulier. oro_behat_extension: elements: Payment Method Config Type Field: class: Oro\\Bundle\\PaymentBundle\\Tests\\Behat\\Element\\PaymentMethodConfigType PaymentRuleForm: selector: \"form[id^='oro_payment_methods_configs_rule']\" class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: mapping: Method: type: 'xpath' locator: '//div[@id[starts-with(.,\"uniform-oro_payment_methods_configs_rule_method\")]]' element: Payment Method Config Type Field Vous devez maintenant impl\u00e9menter la m\u00e9thode setValue de l'\u00e9l\u00e9ment: <?php namespace Oro\\Bundle\\PaymentBundle\\Tests\\Behat\\Element; use Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Element; class PaymentMethodConfigType extends Element { /** * {@inheritdoc} */ public function setValue($value) { $values = is_array($value) ? $value : [$value]; foreach ($values as $item) { $parentField = $this->getParent()->getParent()->getParent()->getParent(); $field = $parentField->find('css', 'select'); self::assertNotNull($field, 'Select payment method field not found'); $field->setValue($item); $parentField->clickLink('Add'); $this->getDriver()->waitForAjax(); } } } Vous pouvez maintenant l'utiliser dans une \u00e9tape standard: Feature: Payment Rules CRUD Scenario: Creating Payment Rule Given I login as administrator And I go to System/ Payment Rules And I click \"Create Payment Rule\" When I fill \"Payment Rule Form\" with: | Method | PayPal | Mappages de formulaires int\u00e9gr\u00e9s : Parfois, un formulaire appara\u00eet dans l'iframe. Behat peut passer \u00e0 l'iframe par son identifiant. Pour remplir correctement le formulaire dans l'iframe, sp\u00e9cifiez l'id iframe dans les options du formulaire: oro_behat_extension: elements: MagentoContactUsForm: selector: 'div#page' class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: embedded-id: embedded-form mapping: First name: 'oro_magento_contactus_contact_request[firstName]' Last name: 'oro_magento_contactus_contact_request[lastName]' ELement de page L'\u00e9l\u00e9ment Page encapsule la page Web enti\u00e8re avec son URL et son chemin d'acc\u00e8s \u00e0 la page. Chaque \u00e9l\u00e9ment Page doit \u00e9tendre Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Page . Exemple de Configuration de Page : oro_behat_extension: pages: UserProfileView: class: Oro\\Bundle\\UserBundle\\Tests\\Behat\\Page\\UserProfileView route: 'oro_user_profile_view' Exemple de classe de page: namespace Oro\\Bundle\\UserBundle\\Tests\\Behat\\Page; use Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Page; class UserProfileView extends Page { /** * {@inheritdoc} */ public function open(array $parameters = []) { $userMenu = $this->elementFactory->createElement('UserMenu'); $userMenu->find('css', '[data-toggle=\"dropdown\"]')->click(); $userMenu->clickLink('My User'); } } Vous pouvez maintenant utiliser plusieurs \u00e9tapes significatives: And I open User Profile View page And I should be on User Profile View page","title":"Behat elements form"},{"location":"tests/behat-elements-form/#mappage-des-champs-de-formulaire","text":"Par d\u00e9faut, les tests utilisent le s\u00e9lecteur de champ nomm\u00e9 pour mapper les champs du formulaire. Le s\u00e9lecteur de nom de champ a recherch\u00e9 le champ par son identifiant, son nom, son label ou son placeholder. Vous \u00eates libre d'utiliser n'importe quel s\u00e9lecteur pour mapper des champs de formulaire ou encapsuler un \u00e9l\u00e9ment dans l'\u00e9l\u00e9ment behat particulier. oro_behat_extension: elements: Payment Method Config Type Field: class: Oro\\Bundle\\PaymentBundle\\Tests\\Behat\\Element\\PaymentMethodConfigType PaymentRuleForm: selector: \"form[id^='oro_payment_methods_configs_rule']\" class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: mapping: Method: type: 'xpath' locator: '//div[@id[starts-with(.,\"uniform-oro_payment_methods_configs_rule_method\")]]' element: Payment Method Config Type Field Vous devez maintenant impl\u00e9menter la m\u00e9thode setValue de l'\u00e9l\u00e9ment: <?php namespace Oro\\Bundle\\PaymentBundle\\Tests\\Behat\\Element; use Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Element; class PaymentMethodConfigType extends Element { /** * {@inheritdoc} */ public function setValue($value) { $values = is_array($value) ? $value : [$value]; foreach ($values as $item) { $parentField = $this->getParent()->getParent()->getParent()->getParent(); $field = $parentField->find('css', 'select'); self::assertNotNull($field, 'Select payment method field not found'); $field->setValue($item); $parentField->clickLink('Add'); $this->getDriver()->waitForAjax(); } } } Vous pouvez maintenant l'utiliser dans une \u00e9tape standard: Feature: Payment Rules CRUD Scenario: Creating Payment Rule Given I login as administrator And I go to System/ Payment Rules And I click \"Create Payment Rule\" When I fill \"Payment Rule Form\" with: | Method | PayPal |","title":"Mappage des champs de formulaire"},{"location":"tests/behat-elements-form/#mappages-de-formulaires-integres","text":"Parfois, un formulaire appara\u00eet dans l'iframe. Behat peut passer \u00e0 l'iframe par son identifiant. Pour remplir correctement le formulaire dans l'iframe, sp\u00e9cifiez l'id iframe dans les options du formulaire: oro_behat_extension: elements: MagentoContactUsForm: selector: 'div#page' class: Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Form options: embedded-id: embedded-form mapping: First name: 'oro_magento_contactus_contact_request[firstName]' Last name: 'oro_magento_contactus_contact_request[lastName]'","title":"Mappages de formulaires int\u00e9gr\u00e9s :"},{"location":"tests/behat-elements-form/#element-de-page","text":"L'\u00e9l\u00e9ment Page encapsule la page Web enti\u00e8re avec son URL et son chemin d'acc\u00e8s \u00e0 la page. Chaque \u00e9l\u00e9ment Page doit \u00e9tendre Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Page . Exemple de Configuration de Page : oro_behat_extension: pages: UserProfileView: class: Oro\\Bundle\\UserBundle\\Tests\\Behat\\Page\\UserProfileView route: 'oro_user_profile_view' Exemple de classe de page: namespace Oro\\Bundle\\UserBundle\\Tests\\Behat\\Page; use Oro\\Bundle\\TestFrameworkBundle\\Behat\\Element\\Page; class UserProfileView extends Page { /** * {@inheritdoc} */ public function open(array $parameters = []) { $userMenu = $this->elementFactory->createElement('UserMenu'); $userMenu->find('css', '[data-toggle=\"dropdown\"]')->click(); $userMenu->clickLink('My User'); } } Vous pouvez maintenant utiliser plusieurs \u00e9tapes significatives: And I open User Profile View page And I should be on User Profile View page","title":"ELement de page"},{"location":"tests/behat-exemples/","text":"Ecrire une feature Chaque bundle doit contenir ses propres tests behat pour les fonctionnalit\u00e9s du r\u00e9pertoire {BundleName}/Tests/Behat/Features/ . Chaque fonctionnalit\u00e9 est un fichier distinct avec l'extension .feature et une syntaxe sp\u00e9cifique. Note : Voir la doc de Cucumber pour plus d'infos. Une fonctionnalit\u00e9 commence par ce qui suit: Le mot cl\u00e9 Feature : et le nom de la fonctionnalit\u00e9 (ceux-ci doivent rester sur la m\u00eame ligne), Une description facultative (peut \u00eatre format\u00e9e sur plusieurs lignes). Une description significative est fortement recommand\u00e9e. Vient ensuite le sc\u00e9nario de fonctionnalit\u00e9 - un exemple sp\u00e9cifique qui illustre une r\u00e8gle m\u00e9tier et se compose d'\u00e9tapes s\u00e9quentielles. En plus d'\u00eatre une sp\u00e9cification de test et une documentation de test, un sc\u00e9nario d\u00e9finit les \u00e9tapes de test et sert de sp\u00e9cification ex\u00e9cutable du syst\u00e8me. Normalement, une \u00e9tape commence par Given , When ou Then . S'il existe plusieurs \u00e9tapes Given ou When les unes sous les autres, vous pouvez utiliser And ou But pour les organiser en groupes logiques. Cucumber ne fait pas de diff\u00e9rence entre les mots cl\u00e9s, mais le choix du bon est important pour la lisibilit\u00e9 du sc\u00e9nario dans son ensemble. Jetez un \u0153il \u00e0 la feature login login.feature dans OroUserBundle Feature: User login In order to login in application As an OroCRM admin I need to be able to authenticate Scenario: Success login Given I am on \"/user/login\" When I fill \"Login Form\" with: | Username | admin | | Password | admin | And I press \"Log in\" Then I should be on \"/\" Scenario Outline: Fail login Given I am on \"/user/login\" When I fill \"Login Form\" with: | Username | <login> | | Password | <password> | And I press \"Log in\" Then I should be on \"/user/login\" And I should see \"Invalid user name or password.\" Examples: | login | password | | user | pass | | user2 | pass2 | La ligne Feature: User login d\u00e9marre la fonctionnalit\u00e9 et lui donne un titre. Behat n'analyse pas les trois lignes de texte suivantes: In order to... As an... I need to... Ces lignes fournissent un contexte lisible par l'homme aux personnes qui r\u00e9viseront ou modifieront cette fonctionnalit\u00e9. Ils d\u00e9crivent la valeur commerciale d\u00e9riv\u00e9e de l'inclusion de la fonctionnalit\u00e9 dans le logiciel. La ligne Scenario: Success login d\u00e9marre le sc\u00e9nario et fournit une description. Les six lignes suivantes repr\u00e9sentent les \u00e9tapes du sc\u00e9nario. Chaque \u00e9tape correspond \u00e0 une expression r\u00e9guli\u00e8re d\u00e9finie dans le contexte. La ligne Scenario Outline: Fail login d\u00e9marre le sc\u00e9nario suivant. Dans le plan du sc\u00e9nario, les placeholders sont utilis\u00e9s \u00e0 la place des valeurs r\u00e9elles et les valeurs pour l'ex\u00e9cution du sc\u00e9nario sont fournies sous la forme d'un ensemble d'exemples sous le plan. Le sc\u00e9nario vous aide \u00e0 ex\u00e9cuter ces \u00e9tapes plusieurs fois, en parcourant les valeurs fournies dans la section Exemples: et en testant ainsi le m\u00eame flux avec des entr\u00e9es diff\u00e9rentes. Le plan du sc\u00e9nario est un mod\u00e8le qui n'est jamais ex\u00e9cut\u00e9 seul. Au lieu de cela, un sc\u00e9nario qui suit un plan s'ex\u00e9cute une fois pour chaque ligne dans la section Exemples: en dessous (\u00e0 l'exception de la premi\u00e8re ligne d'en-t\u00eate qui est ignor\u00e9e). Consid\u00e9rez un espace r\u00e9serv\u00e9 comme une variable. Il est remplac\u00e9 par une valeur r\u00e9elle depuis Exemples: , o\u00f9 le texte entre les crochets d'angle de l'espace r\u00e9serv\u00e9 (par exemple, ) correspond au texte de l'en-t\u00eate de la colonne du tableau (par exemple, login).","title":"Behat exemples"},{"location":"tests/behat-exemples/#ecrire-une-feature","text":"Chaque bundle doit contenir ses propres tests behat pour les fonctionnalit\u00e9s du r\u00e9pertoire {BundleName}/Tests/Behat/Features/ . Chaque fonctionnalit\u00e9 est un fichier distinct avec l'extension .feature et une syntaxe sp\u00e9cifique.","title":"Ecrire une feature"},{"location":"tests/behat-exemples/#note","text":"Voir la doc de Cucumber pour plus d'infos. Une fonctionnalit\u00e9 commence par ce qui suit: Le mot cl\u00e9 Feature : et le nom de la fonctionnalit\u00e9 (ceux-ci doivent rester sur la m\u00eame ligne), Une description facultative (peut \u00eatre format\u00e9e sur plusieurs lignes). Une description significative est fortement recommand\u00e9e. Vient ensuite le sc\u00e9nario de fonctionnalit\u00e9 - un exemple sp\u00e9cifique qui illustre une r\u00e8gle m\u00e9tier et se compose d'\u00e9tapes s\u00e9quentielles. En plus d'\u00eatre une sp\u00e9cification de test et une documentation de test, un sc\u00e9nario d\u00e9finit les \u00e9tapes de test et sert de sp\u00e9cification ex\u00e9cutable du syst\u00e8me. Normalement, une \u00e9tape commence par Given , When ou Then . S'il existe plusieurs \u00e9tapes Given ou When les unes sous les autres, vous pouvez utiliser And ou But pour les organiser en groupes logiques. Cucumber ne fait pas de diff\u00e9rence entre les mots cl\u00e9s, mais le choix du bon est important pour la lisibilit\u00e9 du sc\u00e9nario dans son ensemble. Jetez un \u0153il \u00e0 la feature login login.feature dans OroUserBundle Feature: User login In order to login in application As an OroCRM admin I need to be able to authenticate Scenario: Success login Given I am on \"/user/login\" When I fill \"Login Form\" with: | Username | admin | | Password | admin | And I press \"Log in\" Then I should be on \"/\" Scenario Outline: Fail login Given I am on \"/user/login\" When I fill \"Login Form\" with: | Username | <login> | | Password | <password> | And I press \"Log in\" Then I should be on \"/user/login\" And I should see \"Invalid user name or password.\" Examples: | login | password | | user | pass | | user2 | pass2 | La ligne Feature: User login d\u00e9marre la fonctionnalit\u00e9 et lui donne un titre. Behat n'analyse pas les trois lignes de texte suivantes: In order to... As an... I need to... Ces lignes fournissent un contexte lisible par l'homme aux personnes qui r\u00e9viseront ou modifieront cette fonctionnalit\u00e9. Ils d\u00e9crivent la valeur commerciale d\u00e9riv\u00e9e de l'inclusion de la fonctionnalit\u00e9 dans le logiciel. La ligne Scenario: Success login d\u00e9marre le sc\u00e9nario et fournit une description. Les six lignes suivantes repr\u00e9sentent les \u00e9tapes du sc\u00e9nario. Chaque \u00e9tape correspond \u00e0 une expression r\u00e9guli\u00e8re d\u00e9finie dans le contexte. La ligne Scenario Outline: Fail login d\u00e9marre le sc\u00e9nario suivant. Dans le plan du sc\u00e9nario, les placeholders sont utilis\u00e9s \u00e0 la place des valeurs r\u00e9elles et les valeurs pour l'ex\u00e9cution du sc\u00e9nario sont fournies sous la forme d'un ensemble d'exemples sous le plan. Le sc\u00e9nario vous aide \u00e0 ex\u00e9cuter ces \u00e9tapes plusieurs fois, en parcourant les valeurs fournies dans la section Exemples: et en testant ainsi le m\u00eame flux avec des entr\u00e9es diff\u00e9rentes. Le plan du sc\u00e9nario est un mod\u00e8le qui n'est jamais ex\u00e9cut\u00e9 seul. Au lieu de cela, un sc\u00e9nario qui suit un plan s'ex\u00e9cute une fois pour chaque ligne dans la section Exemples: en dessous (\u00e0 l'exception de la premi\u00e8re ligne d'en-t\u00eate qui est ignor\u00e9e). Consid\u00e9rez un espace r\u00e9serv\u00e9 comme une variable. Il est remplac\u00e9 par une valeur r\u00e9elle depuis Exemples: , o\u00f9 le texte entre les crochets d'angle de l'espace r\u00e9serv\u00e9 (par exemple, ) correspond au texte de l'en-t\u00eate de la colonne du tableau (par exemple, login).","title":"Note :"},{"location":"tests/behat-fixtures/","text":"Feature Fixtures : Chaque fois que behat ex\u00e9cute une nouvelle fonctionnalit\u00e9, l'\u00e9tat de l'application est r\u00e9initialis\u00e9 par d\u00e9faut : il n'y a qu'un seul utilisateur administrateur, une organisation, une unit\u00e9 commerciale et des r\u00f4les par d\u00e9faut dans la base de donn\u00e9es. Les tests de fonctionnalit\u00e9s doivent s'appuyer sur les donn\u00e9es disponibles dans l'application apr\u00e8s l'ex\u00e9cution de la commande oro: install. Dans la plupart des cas, cela ne suffit pas. Ainsi, vous avez deux fa\u00e7ons d'obtenir plus de donn\u00e9es dans le syst\u00e8me: en utilisant des fixtures de base ou des fixtures alice. Fixtures basiques Vous pouvez cr\u00e9er un nombre quelconque d'entit\u00e9s dans les tests de fonctionnalit\u00e9s. FixtureContext devine la classe d'entit\u00e9, cr\u00e9e le nombre n\u00e9cessaire d'objets et utilise faker pour remplir les champs requis lorsque leur valeur n'a pas \u00e9t\u00e9 sp\u00e9cifi\u00e9e explicitement. Vous utilisez \u00e0 la fois les r\u00e9f\u00e9rences faker et les r\u00e9f\u00e9rences d'entit\u00e9 dans les appareils en ligne. Given the following contacts: | First Name | Last Name | Email | | Joan | Anderson | <email()> | | Craig | Bishop | <email()> | | Jean | Castillo | <email()> | | Willie | Chavez | <email()> | | Arthur | Fisher | <email()> | | Wanda | Ford | <email()> | And I have 5 Cases And there are 5 calls And there are two users with their own 7 Accounts And there are 3 users with their own 3 Tasks And there is user with its own Account Fixtures Alice Parfois, vous avez besoin de nombreuses entit\u00e9s diff\u00e9rentes avec des relations complexes. Dans de tels cas, vous pouvez utiliser des fixtures Alice. Alice est une biblioth\u00e8que qui vous permet de cr\u00e9er facilement des fixtures au format yml. NOTE : Voir la documentation d'Alice pour plus d'informations. Les fixtures doivent \u00eatre situ\u00e9s dans le r\u00e9pertoire {BundleName}/Tests/Behat/Features/Fixtures. Pour charger une fixture avant l'ex\u00e9cution des tests de fonctionnalit\u00e9, ajoutez une balise (annotation) qui est construite \u00e0 l'aide de la convention suivante @fixture-BundleName:fixture_file_name.yml , par exemple: @fixture-OroCRMBundle:mass_action.yml Feature: Mass Delete records Il est \u00e9galement possible de charger des fixtures pour tout autre bundle disponible pour l'application. Par exemple: @fixture-OroUserBundle:user.yml @fixture-OroOrganizationBundle:BusinessUnit.yml Feature: Adding attributes for workflow transition De plus, Alice vous permet d'inclure des fichiers via l'extension, vous pouvez donc importer des fichiers \u00e0 partir d'autres bundles: include: - '@OroCustomerBundle/Tests/Behat/Features/Fixtures/CustomerUserAmandaRCole.yml' Vous devez toujours inclure les fixtures d'autres bundles avec des entit\u00e9s qui ont \u00e9t\u00e9 d\u00e9clar\u00e9es dans ce bundle R\u00e9f\u00e9rences d'entit\u00e9s Vous pouvez utiliser des r\u00e9f\u00e9rences aux entit\u00e9s dans les fixtures de base et alice . {Bundle}\\Tests\\Behat\\ReferenceRepositoryInitializer est utilis\u00e9 pour cr\u00e9er des r\u00e9f\u00e9rences pour des objets qui existent d\u00e9j\u00e0 dans la base de donn\u00e9es. Il est interdit de modifier ou d'ajouter de nouvelles entit\u00e9s dans le Initializer. Il doit impl\u00e9menter ReferenceRepositoryInitializerInterface et ne doit pas avoir de d\u00e9pendances. Pour afficher toutes les r\u00e9f\u00e9rences, utilisez la commande bin/behat --available-references . Les r\u00e9f\u00e9rences les plus utilis\u00e9es sont: @admin - Utilisateur Admin @adminRole - Administrator role @organization - Default organization @business_unit - Default business unit","title":"Behat fixtures"},{"location":"tests/behat-fixtures/#feature-fixtures","text":"Chaque fois que behat ex\u00e9cute une nouvelle fonctionnalit\u00e9, l'\u00e9tat de l'application est r\u00e9initialis\u00e9 par d\u00e9faut : il n'y a qu'un seul utilisateur administrateur, une organisation, une unit\u00e9 commerciale et des r\u00f4les par d\u00e9faut dans la base de donn\u00e9es. Les tests de fonctionnalit\u00e9s doivent s'appuyer sur les donn\u00e9es disponibles dans l'application apr\u00e8s l'ex\u00e9cution de la commande oro: install. Dans la plupart des cas, cela ne suffit pas. Ainsi, vous avez deux fa\u00e7ons d'obtenir plus de donn\u00e9es dans le syst\u00e8me: en utilisant des fixtures de base ou des fixtures alice.","title":"Feature Fixtures :"},{"location":"tests/behat-fixtures/#fixtures-basiques","text":"Vous pouvez cr\u00e9er un nombre quelconque d'entit\u00e9s dans les tests de fonctionnalit\u00e9s. FixtureContext devine la classe d'entit\u00e9, cr\u00e9e le nombre n\u00e9cessaire d'objets et utilise faker pour remplir les champs requis lorsque leur valeur n'a pas \u00e9t\u00e9 sp\u00e9cifi\u00e9e explicitement. Vous utilisez \u00e0 la fois les r\u00e9f\u00e9rences faker et les r\u00e9f\u00e9rences d'entit\u00e9 dans les appareils en ligne. Given the following contacts: | First Name | Last Name | Email | | Joan | Anderson | <email()> | | Craig | Bishop | <email()> | | Jean | Castillo | <email()> | | Willie | Chavez | <email()> | | Arthur | Fisher | <email()> | | Wanda | Ford | <email()> | And I have 5 Cases And there are 5 calls And there are two users with their own 7 Accounts And there are 3 users with their own 3 Tasks And there is user with its own Account","title":"Fixtures basiques"},{"location":"tests/behat-fixtures/#fixtures-alice","text":"Parfois, vous avez besoin de nombreuses entit\u00e9s diff\u00e9rentes avec des relations complexes. Dans de tels cas, vous pouvez utiliser des fixtures Alice. Alice est une biblioth\u00e8que qui vous permet de cr\u00e9er facilement des fixtures au format yml.","title":"Fixtures Alice"},{"location":"tests/behat-fixtures/#note","text":"Voir la documentation d'Alice pour plus d'informations. Les fixtures doivent \u00eatre situ\u00e9s dans le r\u00e9pertoire {BundleName}/Tests/Behat/Features/Fixtures. Pour charger une fixture avant l'ex\u00e9cution des tests de fonctionnalit\u00e9, ajoutez une balise (annotation) qui est construite \u00e0 l'aide de la convention suivante @fixture-BundleName:fixture_file_name.yml , par exemple: @fixture-OroCRMBundle:mass_action.yml Feature: Mass Delete records Il est \u00e9galement possible de charger des fixtures pour tout autre bundle disponible pour l'application. Par exemple: @fixture-OroUserBundle:user.yml @fixture-OroOrganizationBundle:BusinessUnit.yml Feature: Adding attributes for workflow transition De plus, Alice vous permet d'inclure des fichiers via l'extension, vous pouvez donc importer des fichiers \u00e0 partir d'autres bundles: include: - '@OroCustomerBundle/Tests/Behat/Features/Fixtures/CustomerUserAmandaRCole.yml' Vous devez toujours inclure les fixtures d'autres bundles avec des entit\u00e9s qui ont \u00e9t\u00e9 d\u00e9clar\u00e9es dans ce bundle","title":"NOTE :"},{"location":"tests/behat-fixtures/#references-dentites","text":"Vous pouvez utiliser des r\u00e9f\u00e9rences aux entit\u00e9s dans les fixtures de base et alice . {Bundle}\\Tests\\Behat\\ReferenceRepositoryInitializer est utilis\u00e9 pour cr\u00e9er des r\u00e9f\u00e9rences pour des objets qui existent d\u00e9j\u00e0 dans la base de donn\u00e9es. Il est interdit de modifier ou d'ajouter de nouvelles entit\u00e9s dans le Initializer. Il doit impl\u00e9menter ReferenceRepositoryInitializerInterface et ne doit pas avoir de d\u00e9pendances. Pour afficher toutes les r\u00e9f\u00e9rences, utilisez la commande bin/behat --available-references . Les r\u00e9f\u00e9rences les plus utilis\u00e9es sont: @admin - Utilisateur Admin @adminRole - Administrator role @organization - Default organization @business_unit - Default business unit","title":"R\u00e9f\u00e9rences d'entit\u00e9s"},{"location":"tests/behat-isolation/","text":"Chaque fonctionnalit\u00e9 peut interagir avec l'application et effectuer des op\u00e9rations CRUD. Par cons\u00e9quent, la base de donn\u00e9es peut \u00eatre modifi\u00e9e. Pour \u00e9viter les collisions de donn\u00e9es, les fonctionnalit\u00e9s sont isol\u00e9es: la base de donn\u00e9es et les r\u00e9pertoires de cache sont vid\u00e9s avant d'ex\u00e9cuter les tests de fonctionnalit\u00e9s; ils sont restaur\u00e9s une fois l'ex\u00e9cution des tests de fonctionnalit\u00e9s termin\u00e9e. Chaque isolateur doit impl\u00e9menter l'interface Oro\\Bundle\\TestFrameworkBundle\\Behat\\Isolation\\IsolatorInterface et le tag `oro_behat.isolator avec de la priorit\u00e9. D\u00e9sactiver l'isolation des fonctionnalit\u00e9s Vous pouvez d\u00e9sactiver l'isolation des fonctionnalit\u00e9s en ajoutant l'option -skip-isolators=database,cache \u00e0 la commande console behat. Dans ce cas, la combinaison des tests de fonctionnalit\u00e9 peut s'ex\u00e9cuter beaucoup plus rapidement, mais la logique de test doit se soucier de la coh\u00e9rence de la base de donn\u00e9es et du cache.","title":"Behat isolation"},{"location":"tests/behat-isolation/#desactiver-lisolation-des-fonctionnalites","text":"Vous pouvez d\u00e9sactiver l'isolation des fonctionnalit\u00e9s en ajoutant l'option -skip-isolators=database,cache \u00e0 la commande console behat. Dans ce cas, la combinaison des tests de fonctionnalit\u00e9 peut s'ex\u00e9cuter beaucoup plus rapidement, mais la logique de test doit se soucier de la coh\u00e9rence de la base de donn\u00e9es et du cache.","title":"D\u00e9sactiver l'isolation des fonctionnalit\u00e9s"},{"location":"tests/behat-symfony/","text":"Behat est une application console Symfony avec son propre conteneur et ses propres services. Un conteneur Behat peut \u00eatre configur\u00e9 via des extensions en utilisant behat.yml \u00e0 la racine du r\u00e9pertoire d'application. Le conteneur d'application peut \u00eatre utilis\u00e9 par le noyau inject\u00e9 dans votre contexte apr\u00e8s avoir impl\u00e9ment\u00e9 KernelAwareContext et utilis\u00e9 le trait KernelDictionary. use Behat\\Symfony2Extension\\Context\\KernelAwareContext; use Behat\\Symfony2Extension\\Context\\KernelDictionary; use Oro\\Bundle\\TestFrameworkBundle\\Behat\\Context\\OroFeatureContext; class FeatureContext extends OroFeatureContext implements KernelAwareContext { use KernelDictionary; public function useContainer() { $doctrine = $this->getContainer()->get('doctrine'); } } De plus, vous pouvez injecter des services dans le contexte behat: oro_behat_extension: suites: OroCustomerAccountBridgeBundle: contexts: - OroImportExportBundle::ImportExportContext: - '@oro_entity.entity_alias_resolver' - '@oro_importexport.processor.registry'","title":"Behat symfony"},{"location":"tests/behat-tips/","text":"Health Checkers Behat a une possibilit\u00e9 native d'invoquer des formateurs sans ex\u00e9cuter les tests et les hooks. Vous pouvez essayer: bin/behat --dry-run Cela peut \u00eatre utile au cas o\u00f9 vous n'\u00eates pas s\u00fbr d'avoir d\u00e9clar\u00e9 tout le contexte n\u00e9cessaire \u00e0 votre fonctionnalit\u00e9. OroBehatExtension am\u00e9liore cette fonctionnalit\u00e9 et ajoute des fonctionnalit\u00e9s suppl\u00e9mentaires. Erreurs Erreur courante : Couldn\u2019t generate random unique value for OroBundleUserBundleEntityUser: username in 128 tries hot fix: V\u00e9rifiez votre fixtures. Supprimez le suffixe (unique) dans la propri\u00e9t\u00e9 d'entit\u00e9 dans le luminaire d'entit\u00e9, comme dans l'exemple suivant: Fixture incorrect : yaml Oro\\Bundle\\UserBundle\\Entity\\User: charlie: firstName: Marge lastName: Marge Simpson username (unique): marge228 Correction Oro\\Bundle\\UserBundle\\Entity\\User: charlie: firstName: Marge lastName: Marge Simpson username: marge228 Erreur racine Alice se souvient de toutes les valeurs de la propri\u00e9t\u00e9 d'entit\u00e9 donn\u00e9e et essaie de g\u00e9n\u00e9rer une valeur unique, mais cela provoque des probl\u00e8mes lorsqu'il n'y a qu'une seule valeur pour la propri\u00e9t\u00e9 d'entit\u00e9. Cette option peut toujours \u00eatre utilis\u00e9e si elle est combin\u00e9e avec la fausse valeur g\u00e9n\u00e9r\u00e9e automatiquement, comme dans l'exemple suivant: Oro\\Bundle\\UserBundle\\Entity\\User: charlie: firstName (unique): <firstName()> lastName: Marge Simpson username: marge228 Ajouter des extraits Le d\u00e9veloppement des fonctionnalit\u00e9s comprend les \u00e9tapes de conception suivantes: Cr\u00e9ez un brouillon de la fonctionnalit\u00e9: impl\u00e9mentez un sc\u00e9nario de haut niveau qui couvre l'histoire. \u00c0 ce stade, vous devez avoir une compr\u00e9hension claire des r\u00e9sultats commerciaux obtenus par l'automatisation des tests de fonctionnalit\u00e9s. Sp\u00e9cifiez tous les sc\u00e9narios susceptibles de se produire lors de l'utilisation de la fonction. Les \u00e9tapes exactes ne sont pas n\u00e9cessaires. Finalisez la vue d'ensemble de la mise en \u0153uvre et planifiez les diff\u00e9rentes \u00e9tapes. Certaines \u00e9tapes peuvent d\u00e9j\u00e0 \u00eatre enti\u00e8rement automatis\u00e9es. Id\u00e9alement, vous devez automatiser les \u00e9tapes manquantes apr\u00e8s avoir pr\u00e9vu de les utiliser dans vos sc\u00e9narios de test de fonctionnalit\u00e9s. Si la fonctionnalit\u00e9 de fonctionnalit\u00e9 est d\u00e9j\u00e0 impl\u00e9ment\u00e9e, il est n\u00e9cessaire d'impl\u00e9menter les \u00e9tapes behat impliqu\u00e9es dans le test de fonctionnalit\u00e9. Cependant, il est parfois impossible de le faire imm\u00e9diatement (en raison de l'impl\u00e9mentation incompl\u00e8te des fonctionnalit\u00e9s, des probl\u00e8mes de blocage ou des informations manquantes). Dans ce cas, vous pouvez temporairement vous moquer des \u00e9tapes qui manquent d'impl\u00e9mentation. Un moyen rapide de le faire consiste \u00e0 ex\u00e9cuter dry-run sur vos tests de fonctionnalit\u00e9s. Dans la console, ex\u00e9cutez la commande suivante: bin/behat path/to/your.feature --dry-run --append-snippets --snippets-type=regex La fonctionnalit\u00e9 est ex\u00e9cut\u00e9e en mode \u2013dry-run , au stade final de l'ex\u00e9cution, vous \u00eates invit\u00e9 \u00e0 ajouter des \u00e9tapes de mise en \u0153uvre simul\u00e9e non d\u00e9finies \u00e0 l'un des contextes existants. Comment trouver l'\u00e9tape n\u00e9cessaire Lorsque vous concevez des sc\u00e9narios d'automatisation de test pour la nouvelle fonctionnalit\u00e9, vous pouvez avoir du mal \u00e0 trouver des \u00e9tapes \u00e0 r\u00e9utiliser parmi les centaines d'\u00e9tapes d\u00e9j\u00e0 automatis\u00e9es. Utilisez les conseils ci-dessous pour trouver l'\u00e9tape n\u00e9cessaire. Suggestion automatique dans PhpStorm Lors de la conception d'un sc\u00e9nario dans le fichier de fonctionnalit\u00e9s, PhpStorm vous propose des conseils sur les \u00e9tapes impl\u00e9ment\u00e9es qui correspondent aux mots cl\u00e9s. Par exemple, lorsque vous tapez grid ou form, les \u00e9tapes qui impliquent ces \u00e9l\u00e9ments apparaissent dans le bloc de suggestions. Si PhpStorm ne vous propose aucun conseil lors de la frappe, veuillez v\u00e9rifier les points suivants: Vous avez install\u00e9 les vendors Vous avez install\u00e9 le plugin behat pour PhpStorm Trouvez le contexte n\u00e9cessaire Chaque classe Context doit impl\u00e9menter l'interface Behat\\Behat\\Context\\Context . Obtenez la liste des contextes impl\u00e9ment\u00e9s et trouvez celui n\u00e9cessaire par nom. Habituellement, le nom du contexte est explicite, par exemple, GridContext, FormContext, ACLContext, etc. Utiliser Grep dans la console Si, pour une raison quelconque, vous n'utilisez pas PhpStorm ou le plugin Behat, vous pouvez toujours trouver l'\u00e9tape n\u00e9cessaire en filtrant la sortie de la commande qui pr\u00e9visualise toutes les \u00e9tapes de la fonctionnalit\u00e9 (utilisez Grep). Tapez la commande suivante dans votre console: bin/behat -dl -s AcmeDemoBundle | grep \"flash message\" bin/behat -dl -s AcmeDemoBundle | grep \"grid\" PS : Vous ne pouvez utiliser l'interface de ligne de commande behat qu'apr\u00e8s avoir install\u00e9 l'application.","title":"Behat tips"},{"location":"tests/behat-tips/#health-checkers","text":"Behat a une possibilit\u00e9 native d'invoquer des formateurs sans ex\u00e9cuter les tests et les hooks. Vous pouvez essayer: bin/behat --dry-run Cela peut \u00eatre utile au cas o\u00f9 vous n'\u00eates pas s\u00fbr d'avoir d\u00e9clar\u00e9 tout le contexte n\u00e9cessaire \u00e0 votre fonctionnalit\u00e9. OroBehatExtension am\u00e9liore cette fonctionnalit\u00e9 et ajoute des fonctionnalit\u00e9s suppl\u00e9mentaires.","title":"Health Checkers"},{"location":"tests/behat-tips/#erreurs","text":"Erreur courante : Couldn\u2019t generate random unique value for OroBundleUserBundleEntityUser: username in 128 tries hot fix: V\u00e9rifiez votre fixtures. Supprimez le suffixe (unique) dans la propri\u00e9t\u00e9 d'entit\u00e9 dans le luminaire d'entit\u00e9, comme dans l'exemple suivant: Fixture incorrect : yaml Oro\\Bundle\\UserBundle\\Entity\\User: charlie: firstName: Marge lastName: Marge Simpson username (unique): marge228 Correction Oro\\Bundle\\UserBundle\\Entity\\User: charlie: firstName: Marge lastName: Marge Simpson username: marge228 Erreur racine Alice se souvient de toutes les valeurs de la propri\u00e9t\u00e9 d'entit\u00e9 donn\u00e9e et essaie de g\u00e9n\u00e9rer une valeur unique, mais cela provoque des probl\u00e8mes lorsqu'il n'y a qu'une seule valeur pour la propri\u00e9t\u00e9 d'entit\u00e9. Cette option peut toujours \u00eatre utilis\u00e9e si elle est combin\u00e9e avec la fausse valeur g\u00e9n\u00e9r\u00e9e automatiquement, comme dans l'exemple suivant: Oro\\Bundle\\UserBundle\\Entity\\User: charlie: firstName (unique): <firstName()> lastName: Marge Simpson username: marge228","title":"Erreurs"},{"location":"tests/behat-tips/#ajouter-des-extraits","text":"Le d\u00e9veloppement des fonctionnalit\u00e9s comprend les \u00e9tapes de conception suivantes: Cr\u00e9ez un brouillon de la fonctionnalit\u00e9: impl\u00e9mentez un sc\u00e9nario de haut niveau qui couvre l'histoire. \u00c0 ce stade, vous devez avoir une compr\u00e9hension claire des r\u00e9sultats commerciaux obtenus par l'automatisation des tests de fonctionnalit\u00e9s. Sp\u00e9cifiez tous les sc\u00e9narios susceptibles de se produire lors de l'utilisation de la fonction. Les \u00e9tapes exactes ne sont pas n\u00e9cessaires. Finalisez la vue d'ensemble de la mise en \u0153uvre et planifiez les diff\u00e9rentes \u00e9tapes. Certaines \u00e9tapes peuvent d\u00e9j\u00e0 \u00eatre enti\u00e8rement automatis\u00e9es. Id\u00e9alement, vous devez automatiser les \u00e9tapes manquantes apr\u00e8s avoir pr\u00e9vu de les utiliser dans vos sc\u00e9narios de test de fonctionnalit\u00e9s. Si la fonctionnalit\u00e9 de fonctionnalit\u00e9 est d\u00e9j\u00e0 impl\u00e9ment\u00e9e, il est n\u00e9cessaire d'impl\u00e9menter les \u00e9tapes behat impliqu\u00e9es dans le test de fonctionnalit\u00e9. Cependant, il est parfois impossible de le faire imm\u00e9diatement (en raison de l'impl\u00e9mentation incompl\u00e8te des fonctionnalit\u00e9s, des probl\u00e8mes de blocage ou des informations manquantes). Dans ce cas, vous pouvez temporairement vous moquer des \u00e9tapes qui manquent d'impl\u00e9mentation. Un moyen rapide de le faire consiste \u00e0 ex\u00e9cuter dry-run sur vos tests de fonctionnalit\u00e9s. Dans la console, ex\u00e9cutez la commande suivante: bin/behat path/to/your.feature --dry-run --append-snippets --snippets-type=regex La fonctionnalit\u00e9 est ex\u00e9cut\u00e9e en mode \u2013dry-run , au stade final de l'ex\u00e9cution, vous \u00eates invit\u00e9 \u00e0 ajouter des \u00e9tapes de mise en \u0153uvre simul\u00e9e non d\u00e9finies \u00e0 l'un des contextes existants.","title":"Ajouter des extraits"},{"location":"tests/behat-tips/#comment-trouver-letape-necessaire","text":"Lorsque vous concevez des sc\u00e9narios d'automatisation de test pour la nouvelle fonctionnalit\u00e9, vous pouvez avoir du mal \u00e0 trouver des \u00e9tapes \u00e0 r\u00e9utiliser parmi les centaines d'\u00e9tapes d\u00e9j\u00e0 automatis\u00e9es. Utilisez les conseils ci-dessous pour trouver l'\u00e9tape n\u00e9cessaire. Suggestion automatique dans PhpStorm Lors de la conception d'un sc\u00e9nario dans le fichier de fonctionnalit\u00e9s, PhpStorm vous propose des conseils sur les \u00e9tapes impl\u00e9ment\u00e9es qui correspondent aux mots cl\u00e9s. Par exemple, lorsque vous tapez grid ou form, les \u00e9tapes qui impliquent ces \u00e9l\u00e9ments apparaissent dans le bloc de suggestions. Si PhpStorm ne vous propose aucun conseil lors de la frappe, veuillez v\u00e9rifier les points suivants: Vous avez install\u00e9 les vendors Vous avez install\u00e9 le plugin behat pour PhpStorm Trouvez le contexte n\u00e9cessaire Chaque classe Context doit impl\u00e9menter l'interface Behat\\Behat\\Context\\Context . Obtenez la liste des contextes impl\u00e9ment\u00e9s et trouvez celui n\u00e9cessaire par nom. Habituellement, le nom du contexte est explicite, par exemple, GridContext, FormContext, ACLContext, etc. Utiliser Grep dans la console Si, pour une raison quelconque, vous n'utilisez pas PhpStorm ou le plugin Behat, vous pouvez toujours trouver l'\u00e9tape n\u00e9cessaire en filtrant la sortie de la commande qui pr\u00e9visualise toutes les \u00e9tapes de la fonctionnalit\u00e9 (utilisez Grep). Tapez la commande suivante dans votre console: bin/behat -dl -s AcmeDemoBundle | grep \"flash message\" bin/behat -dl -s AcmeDemoBundle | grep \"grid\" PS : Vous ne pouvez utiliser l'interface de ligne de commande behat qu'apr\u00e8s avoir install\u00e9 l'application.","title":"Comment trouver l'\u00e9tape n\u00e9cessaire"},{"location":"tests/behat/","text":"Concepts Les informations ci-dessous r\u00e9sume les concepts et les outils qui sont importants pour la compr\u00e9hension et l\u2019utilisation du framework de test inclus dans OroBehatExtension. Behavior-driven development (BDD) est un processus de d\u00e9veloppement logiciel issu du d\u00e9veloppement ax\u00e9 sur les tests (TDD). Le BDD combine les techniques g\u00e9n\u00e9rales et les principes de TDD avec des id\u00e9es de conception ax\u00e9e sur le domaine et l'analyse d'objet et du design pour fournir aux \u00e9quipes de d\u00e9veloppement et de gestion de logiciels des outils partag\u00e9s et un processus partag\u00e9 de collaboration pour le d\u00e9veloppement de logiciels. Behat est un framework de d\u00e9veloppement bas\u00e9 sur le comportement pour PHP. Cet outil permet de d\u00e9crire le comportement de l'application voulue en utilisant Php et Gherking Vous pouvez utiliser Behat pour d\u00e9crire tout ce que vous pouvez d\u00e9crire dans la logique m\u00e9tier. Outils, applications GUI, applications Web, etc. Mink est une extension de Behat qui vas permettre de controller un navigateur durant les tests en utilisant PHP. Il vas utiliser des emulateurs de navigateurs , l'avantage d'utiliser Mink c'est qu'il supprime les diff\u00e9rences entres les diff\u00e9rents emulateurs de navigateur et leurs drivers. WebDriver est un protocole qui permet de controller des navigateurs en JSON. MinkSelenium2Driver vas faire le lien entre Mink vers Selenium en utilisant le protocole WebDriver, c'est un driver universel. ChromeDriver est un driver comme Selenium2Driver mais ne fonctionne que pour chrome et a la particularit\u00e9 de fonctionner sans Selenium ce qui rend les tests plus rapides sur chrome. Selenium est un framework de test informatique d\u00e9velopp\u00e9 en Java qui est compos\u00e9 de 3 grandes briques : Selenium WebDriver : Framework de test fonctionnel permettant l\u2019\u00e9criture de scripts de test automatis\u00e9s en differents language.Il met a disposition une API pour controller tout les navigateurs. Selenium IDE : qui permet de cr\u00e9er des script , sous forme d'extension chrome our firefox, pour controller des navigateurs. Selenium Grid : Qui se compose d'un hub et de nodes, permet de lancer des test sur plusieurs navigateurs en m\u00eame temps. Symfony2Extension qui ajoute une int\u00e9gration pour Symfony avec Behat. OroTestFrameworkExtension est une extension de behat pour int\u00e9grer Oro, il ajoute des features tel que : l'autoloading des contextes, permet de construire des suites de tests sp\u00e9cifiques. la possibilit\u00e9 de d\u00e9clarer des 'Elements' facilement dans le fichier de config behat.yml Mapper facilement des champs de formulaires OroElementFactory est une classe qui permet de manipuler des \u00e9l\u00e9ments sur la page: hasElement($name) createElement($name, NodeElement $context = null) guessElement($name) findElementContains($name, $text, Element $context = null) findElementContainsByCss($name, $text, Element $context = null) findElementContainsByXPath($name, $text, $useChildren = true, Element $context = null) findAllElements($name, NodeElement $context = null) getPage() findElement($name, $selectorCallback, Element $context = null) et d'autre fonctions .... Le contexte : Chaque phrase en Gherkin est associ\u00e9e \u00e0 une m\u00e9thode PHP gr\u00e2ce aux classes de contexte.La phrase est situ\u00e9e dans une annotation au-dessus de la fonction \u00e0 appeler. L\u2019annotation peut contenir une expression rationnelle ou une phrase avec des placeholders commen\u00e7ant par deux points. Chaque parenth\u00e8se de capture de l\u2019expression rationnelle ou placeholder sera un argument de la m\u00e9thode PHP appel\u00e9e pour ex\u00e9cuter la phrase du test. Architecture : Conventions : Conventions Configuration Configuration Injection de d\u00e9pendances Architecture Autoload Suites Autoloading Feature Isolation Isolation Elements et formulaires Elements et formulaire Fixtures : Fixtures Ecriture des tests Exemples d'un test behat Autres : Tips,tricks,bugfix Docs relatives Behat Gherkin Mink WebDriver MinkSelenium2Driver ChromeDriver Selenium Symfony2Extension","title":"Behat"},{"location":"tests/behat/#concepts","text":"Les informations ci-dessous r\u00e9sume les concepts et les outils qui sont importants pour la compr\u00e9hension et l\u2019utilisation du framework de test inclus dans OroBehatExtension. Behavior-driven development (BDD) est un processus de d\u00e9veloppement logiciel issu du d\u00e9veloppement ax\u00e9 sur les tests (TDD). Le BDD combine les techniques g\u00e9n\u00e9rales et les principes de TDD avec des id\u00e9es de conception ax\u00e9e sur le domaine et l'analyse d'objet et du design pour fournir aux \u00e9quipes de d\u00e9veloppement et de gestion de logiciels des outils partag\u00e9s et un processus partag\u00e9 de collaboration pour le d\u00e9veloppement de logiciels. Behat est un framework de d\u00e9veloppement bas\u00e9 sur le comportement pour PHP. Cet outil permet de d\u00e9crire le comportement de l'application voulue en utilisant Php et Gherking Vous pouvez utiliser Behat pour d\u00e9crire tout ce que vous pouvez d\u00e9crire dans la logique m\u00e9tier. Outils, applications GUI, applications Web, etc. Mink est une extension de Behat qui vas permettre de controller un navigateur durant les tests en utilisant PHP. Il vas utiliser des emulateurs de navigateurs , l'avantage d'utiliser Mink c'est qu'il supprime les diff\u00e9rences entres les diff\u00e9rents emulateurs de navigateur et leurs drivers. WebDriver est un protocole qui permet de controller des navigateurs en JSON. MinkSelenium2Driver vas faire le lien entre Mink vers Selenium en utilisant le protocole WebDriver, c'est un driver universel. ChromeDriver est un driver comme Selenium2Driver mais ne fonctionne que pour chrome et a la particularit\u00e9 de fonctionner sans Selenium ce qui rend les tests plus rapides sur chrome. Selenium est un framework de test informatique d\u00e9velopp\u00e9 en Java qui est compos\u00e9 de 3 grandes briques : Selenium WebDriver : Framework de test fonctionnel permettant l\u2019\u00e9criture de scripts de test automatis\u00e9s en differents language.Il met a disposition une API pour controller tout les navigateurs. Selenium IDE : qui permet de cr\u00e9er des script , sous forme d'extension chrome our firefox, pour controller des navigateurs. Selenium Grid : Qui se compose d'un hub et de nodes, permet de lancer des test sur plusieurs navigateurs en m\u00eame temps. Symfony2Extension qui ajoute une int\u00e9gration pour Symfony avec Behat. OroTestFrameworkExtension est une extension de behat pour int\u00e9grer Oro, il ajoute des features tel que : l'autoloading des contextes, permet de construire des suites de tests sp\u00e9cifiques. la possibilit\u00e9 de d\u00e9clarer des 'Elements' facilement dans le fichier de config behat.yml Mapper facilement des champs de formulaires OroElementFactory est une classe qui permet de manipuler des \u00e9l\u00e9ments sur la page: hasElement($name) createElement($name, NodeElement $context = null) guessElement($name) findElementContains($name, $text, Element $context = null) findElementContainsByCss($name, $text, Element $context = null) findElementContainsByXPath($name, $text, $useChildren = true, Element $context = null) findAllElements($name, NodeElement $context = null) getPage() findElement($name, $selectorCallback, Element $context = null) et d'autre fonctions .... Le contexte : Chaque phrase en Gherkin est associ\u00e9e \u00e0 une m\u00e9thode PHP gr\u00e2ce aux classes de contexte.La phrase est situ\u00e9e dans une annotation au-dessus de la fonction \u00e0 appeler. L\u2019annotation peut contenir une expression rationnelle ou une phrase avec des placeholders commen\u00e7ant par deux points. Chaque parenth\u00e8se de capture de l\u2019expression rationnelle ou placeholder sera un argument de la m\u00e9thode PHP appel\u00e9e pour ex\u00e9cuter la phrase du test.","title":"Concepts"},{"location":"tests/behat/#architecture","text":"","title":"Architecture :"},{"location":"tests/behat/#conventions","text":"Conventions","title":"Conventions :"},{"location":"tests/behat/#configuration","text":"Configuration","title":"Configuration"},{"location":"tests/behat/#injection-de-dependances","text":"Architecture","title":"Injection de d\u00e9pendances"},{"location":"tests/behat/#autoload-suites","text":"Autoloading","title":"Autoload Suites"},{"location":"tests/behat/#feature-isolation","text":"Isolation","title":"Feature Isolation"},{"location":"tests/behat/#elements-et-formulaires","text":"Elements et formulaire","title":"Elements et formulaires"},{"location":"tests/behat/#fixtures","text":"Fixtures","title":"Fixtures :"},{"location":"tests/behat/#ecriture-des-tests","text":"Exemples d'un test behat","title":"Ecriture des tests"},{"location":"tests/behat/#autres","text":"Tips,tricks,bugfix","title":"Autres :"},{"location":"tests/behat/#docs-relatives","text":"Behat Gherkin Mink WebDriver MinkSelenium2Driver ChromeDriver Selenium Symfony2Extension","title":"Docs relatives"},{"location":"tests/functional/","text":"Tests fonctionnels Les tests fonctionnels permettent de v\u00e9rifier l\u2019int\u00e9gration des diff\u00e9rentes couches d\u2019une application. Dans cet article, vous apprendrez comment vous pouvez am\u00e9liorer l\u2019exp\u00e9rience de la r\u00e9daction de tests fonctionnels avec Oroplatform. Il est recommand\u00e9 de lire la Doc Symfony concernant les tests avant de continuer. Vous devriez \u00e9galement conna\u00eetre PhpUnit Quand r\u00e9diger les tests fonctionnels Les tests fonctionnels sont g\u00e9n\u00e9ralement r\u00e9dig\u00e9s pour les : Contr\u00f4leurs Commandes D\u00e9p\u00f4ts Autres services L\u2019objectif des tests fonctionnels n\u2019est pas de tester des classes s\u00e9par\u00e9es (tests unitaires), mais de tester l\u2019int\u00e9gration des diff\u00e9rentes parties d\u2019une application. Ajouter des tests fonctionnels pour compl\u00e9ter les tests unitaires pour les raisons suivantes : Vous pouvez tester le syst\u00e8me multi-composants et vous assurer qu\u2019il fonctionne comme un tout. Vous pouvez \u00e9viter la simulation(mocking) de l\u2019interface compliqu\u00e9e ou de la couche de manipulation de donn\u00e9es (comme les classes de doctrine pour construire une requ\u00eate). Les tests unitaires peuvent r\u00e9ussir m\u00eame si les fonctionnalit\u00e9s ne fonctionnent pas correctement. Environnement de test Initialisation du client et avertissement quand aux chargement des fixtures Pour am\u00e9liorer la performance de l\u2019ex\u00e9cution du test, l\u2019initialisation d\u2019un client n\u2019est effectu\u00e9e qu\u2019une seule fois par cas de test par d\u00e9faut. Cela signifie que le noyau de l\u2019application Symfony sera d\u00e9marr\u00e9 une fois par cas de test. Les fixtures sont \u00e9galement charg\u00e9s une seule fois par cas de test par d\u00e9faut. D\u2019une part, initialiser et charger des fixtures une fois par cas de test augmente la performance de l\u2019ex\u00e9cution de test mais peut aussi causer des bugs car l\u2019\u00e9tat des fixtures et du noyau (et par cons\u00e9quent, le conteneur de service) sera partag\u00e9 par d\u00e9faut entre les m\u00e9thodes de test de cas de test s\u00e9par\u00e9s. Assurez-vous de r\u00e9initialiser cet \u00e9tat si n\u00e9cessaire. Configuration d'un environnement de test Vous devez configurer les param\u00e8tres suivants pour l\u2019environnement de test : Cr\u00e9er une base de donn\u00e9es distincte pour les tests (p. ex., ajouter le suffixe \u00ab _test \u00bb) : Configurez les param\u00e8tres h\u00f4te, port et authentification pour la base de donn\u00e9es, le serveur de messagerie et le serveur de socket web dans le fichier parameters_test.yml : Par exemple : # config/parameters_test.yml parameters: database_host: 127.0.0.1 database_port: null database_name: crm_test database_user: root database_password: null mailer_transport: smtp mailer_host: 127.0.0.1 mailer_port: null mailer_encryption: null mailer_user: null mailer_password: null session_handler: null locale: en secret: ThisTokenIsNotSoSecretChangeIt installed: false Installez l'application dans un environnement de test bin/console oro:install \\ --env=test \\ --organization-name=Oro \\ --user-name=admin \\ --user-email=admin@example.com \\ --user-firstname=John \\ --user-lastname=Doe \\ --user-password=admin \\ --sample-data=n \\ --application-url=http://localhost Lors de l\u2019installation, la structure de la base de donn\u00e9es est configur\u00e9e et les fixtures standard sont charg\u00e9s. Ex\u00e9cuter les tests en utilisant phpunit avec l\u2019option \u2013testsuite appropri\u00e9e (unit ou functionnal). ATTENTION Actuellement, l\u2019ex\u00e9cution de diff\u00e9rents types de tests automatis\u00e9s ensemble n\u2019est pas prise en charge. Il est donc fortement d\u00e9conseill\u00e9 d\u2019ex\u00e9cuter des tests unitaires et des tests fonctionnels c\u00f4te \u00e0 c\u00f4te en une seule ex\u00e9cution, car cela produit des erreurs. Les tests unitaires cr\u00e9ent des objets fictifs qui interf\u00e8rent ult\u00e9rieurement avec l\u2019ex\u00e9cution des tests fonctionnels et cr\u00e9ent une ambigu\u00eft\u00e9 inutile. Il est possible de d\u00e9sactiver les tests unitaires au d\u00e9marrage du test \u00e0 l\u2019aide de l\u2019option testsuite : $ php bin/phpunit -c . / --testsuite=functional $ php bin/phpunit -c . / --testsuite=unit Database Isolation L'annotation @dbIsolationPerTest ajoute une transaction qui sera effectu\u00e9e avant le d\u00e9but d\u2019un test et qui est annul\u00e9e lorsqu\u2019un test se termine. // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; /** * @dbIsolationPerTest */ class FooBarTest extends WebTestCase { // ... } Chargement des data fixtures : Utilisez la m\u00e9thode loadFixtures() pour charger des donn\u00e9es dans un test : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { $this->initClient(); // must be called before! // loading fixtures will be executed once, use the second parameter // $force = true to force the loading $this->loadFixtures([ 'Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadFooData', '@OroFooBarBundle/Tests/Functional/DataFixtures/bar_data.yml', ]); } // ... } Un fixture doit \u00eatre soit un nom de classe qui impl\u00e9mente Doctrine\\Common\\DataFixtures\\FixtureInterface , soit un chemin vers le fichier nelmio/alice. Un exemple de fixture : // src/Oro/Bundle/FooBarBundle/Tests/Functional/DataFixtures/LoadFooData.php namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Oro\\Bundle\\FooBarBundle\\Entity\\FooEntity; class LoadFooData extends AbstractFixture { public function load(ObjectManager $manager) { $entity = new FooEntity(); $manager->persist($entity); $manager->flush(); } } # src/Oro/Bundle/FooBarBundle/Tests/Functional/DataFixtures/bar_data.yml Oro\\Bundle\\FooBarBundle\\Entity\\BarEntity: bar: name: test Vous pouvez \u00e9galement impl\u00e9menter l\u2019interfaceDoctrine\\Common\\DataFixtures\\DependentFixtureInterface qui permet de charger des fixtures en fonction des autres fixtures d\u00e9j\u00e0 charg\u00e9es : // src/Oro/Bundle/FooBarBundle/Tests/Functional/DataFixtures/LoadFooData.php namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\DataFixtures\\DependentFixtureInterface; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; class LoadFooData extends AbstractFixture implements DependentFixtureInterface { public function load(ObjectManager $manager) { // load fixtures } public function getDependencies() { return ['Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadBarData']; } } De plus, vous pouvez utiliser des entit\u00e9s sp\u00e9cifiques aux r\u00e9f\u00e9rences \u00e0 partir de fixtures, par exemple : namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\Persistence\\ObjectManager; use Doctrine\\Common\\DataFixtures\\DependentFixtureInterface; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Oro\\Bundle\\FooBarBundle\\Entity\\FooEntity; class LoadFooData extends AbstractFixture implements DependentFixtureInterface { public function load(ObjectManager $manager) { $entity = new FooEntity(); $manager->persist($entity); $manager->flush(); $this->addReference('my_entity', $entity); } public function getDependencies() { return ['Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadBarData']; } } Maintenant, vous pouvez r\u00e9f\u00e9rencer le fixture par le nom configur\u00e9 dans votre test : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected $entity; protected function setUp() { $this->initClient(); $this->loadFixtures('Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadFooData'); $this->entity = $this->getReference('my_entity'); } // ... } NOTES : Par d\u00e9faut, le gestionnaire d\u2019entit\u00e9s est effac\u00e9 apr\u00e8s le chargement de chaque fixture. Pour \u00e9viter le nettoyage une fixture peut impl\u00e9menterOro\\Bundle\\TestFrameworkBundle\\Test\\DataFixtures\\InitialFixtureInterface. Parfois, vous avez besoin d\u2019une r\u00e9f\u00e9rence \u00e0 l\u2019Organization, d'un User ou d'une BusinessUnit. Les fixtures suivants peuvent \u00eatre utilis\u00e9s pour les charger : Oro\\Bundle\\TestFrameworkBundle\\Tests\\Functional\\DataFixtures\\LoadOrganization Oro\\Bundle\\TestFrameworkBundle\\Tests\\Functional\\DataFixtures\\LoadUser Oro\\Bundle\\TestFrameworkBundle\\Tests\\Functional\\DataFixtures\\LoadBusinessUnit Ecrire des test fonctionnel : Pour cr\u00e9er un test fonctionel : Etendez la classe WebTestCase Pr\u00e9parez une instance de la classe Client Pr\u00e9parez vos fixtures ( Optionnel) Pr\u00e9parez le container Appelez les fonctionnalit\u00e9es du test 6 V\u00e9rifiez le r\u00e9sultat Tests fonctionnel pour les controlleurs : Un test fonctionnel pour un contr\u00f4leur se compose de quelques \u00e9tapes: Faire une requete Tester la r\u00e9ponse Cliquez sur un lien ou soumettez un formulaire Test the response Nettoyer et r\u00e9p\u00e9ter Exemples de pr\u00e9praration du client : L\u2019initialisation simple fonctionne pour tester les commandes et les services lorsque l\u2019authentification n\u2019est pas n\u00e9cessaire. // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { $this->initClient(); // initialization occurres only once per test class // now varialbe $this->client is available } // ... } Initialisation avec les options Appkernel personnalis\u00e9es : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { // first array is Kernel options $this->initClient(['debug' => false]); } // ... } Initialisation avec authentification : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { // second array is service options // this example will create client with server options ['PHP_AUTH_USER' => 'admin@example.com', 'PHP_AUTH_PW' => 'admin'] // make sure you loaded fixture with test user // bin/console doctrine:fixture:load --no-debug --append --no-interaction --env=test --fixtures src/Oro/src/Oro/Bundle/TestFrameworkBundle/Fixtures $this->initClient([], $this->generateBasicAuthHeader()); // init client with custom username and password $this->initClient([], $this->generateBasicAuthHeader('custom_username', 'custom_password')); } // ... } Types de tests fonctionnels Tester les controllers // src/OroCRM/Bundle/TaskBundle/Tests/Functional/Controller/TaskControllersTest.php namespace Oro\\Bundle\\TaskBundle\\Tests\\Functional\\Controller; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; /** * @outputBuffering enabled */ class TaskControllersTest extends WebTestCase { protected function setUp() { $this->initClient([], $this->generateBasicAuthHeader()); } public function testCreate() { $crawler = $this->client->request('GET', $this->getUrl('orocrm_task_create')); $form = $crawler->selectButton('Save and Close')->form(); $form['orocrm_task[subject]'] = 'New task'; $form['orocrm_task[description]'] = 'New description'; $form['orocrm_task[dueDate]'] = '2014-03-04T20:00:00+0000'; $form['orocrm_task[owner]'] = '1'; $form['orocrm_task[reporter]'] = '1'; $this->client->followRedirects(true); $crawler = $this->client->submit($form); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task saved', $crawler->html()); } /** * @depends testCreate */ public function testUpdate() { $response = $this->client->requestGrid( 'tasks-grid', ['tasks-grid[_filter][reporterName][value]' => 'John Doe'] ); $result = $this->getJsonResponseContent($response, 200); $result = reset($result['data']); $crawler = $this->client->request( 'GET', $this->getUrl('orocrm_task_update', ['id' => $result['id']]) ); $form = $crawler->selectButton('Save and Close')->form(); $form['orocrm_task[subject]'] = 'Task updated'; $form['orocrm_task[description]'] = 'Description updated'; $this->client->followRedirects(true); $crawler = $this->client->submit($form); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task saved', $crawler->html()); } /** * @depends testUpdate */ public function testView() { $response = $this->client->requestGrid( 'tasks-grid', ['tasks-grid[_filter][reporterName][value]' => 'John Doe'] ); $result = $this->getJsonResponseContent($response, 200); $result = reset($result['data']); $this->client->request( 'GET', $this->getUrl('orocrm_task_view', ['id' => $result['id']]) ); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task updated - Tasks - Activities', $result->getContent()); } /** * @depends testUpdate */ public function testIndex() { $this->client->request('GET', $this->getUrl('orocrm_task_index')); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task updated', $result->getContent()); } } Tester les ACLs dans les controlleurs : Dans cet exemple, un utilisateur sans autorisations suffisantes essaie d\u2019acc\u00e9der \u00e0 une action du contr\u00f4leur. La m\u00e9thode assertHtmlResponseStatusCodeEquals() est utilis\u00e9e pour s\u2019assurer que l\u2019acc\u00e8s \u00e0 la ressource demand\u00e9e est refus\u00e9 \u00e0 l\u2019utilisateur : namespace Oro\\Bundle\\UserBundle\\Tests\\Functional; use Oro\\Bundle\\UserBundle\\Tests\\Functional\\DataFixtures\\LoadUserData; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; /** * @outputBuffering enabled */ class UsersTest extends WebTestCase { protected function setUp() { $this->initClient(); $this->loadFixtures(['Oro\\Bundle\\UserBundle\\Tests\\Functional\\API\\DataFixtures\\LoadUserData']); } public function testUsersIndex() { $this->client->request( 'GET', $this->getUrl('oro_user_index'), [], [], $this->generateBasicAuthHeader(LoadUserData::USER_NAME, LoadUserData::USER_PASSWORD) ); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 403); } public function testGetUsersAPI() { $this->client->request( 'GET', $this->getUrl('oro_api_get_users'), ['limit' => 100], [], $this->generateWsseAuthHeader(LoadUserData::USER_NAME, LoadUserData::USER_API_KEY) ); $result = $this->client->getResponse(); $this->assertJsonResponseStatusCodeEquals($result, 403); } } Voici un exemple de fixture qui ajoute un utilisateur sans permission : / src/Oro/Bundle/UserBundle/Tests/Functional/DataFixtures/LoadUserData.php namespace Oro\\Bundle\\UserBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Symfony\\Component\\DependencyInjection\\ContainerAwareInterface; use Symfony\\Component\\DependencyInjection\\ContainerInterface; use Oro\\Bundle\\UserBundle\\Entity\\Role; use Oro\\Bundle\\UserBundle\\Entity\\UserApi; class LoadUserData extends AbstractFixture implements ContainerAwareInterface { const USER_NAME = 'user_wo_permissions'; const USER_API_KEY = 'user_api_key'; const USER_PASSWORD = 'user_password'; private $container; public function setContainer(ContainerInterface $container = null) { $this->container = $container; } public function load(ObjectManager $manager) { /** @var \\Oro\\Bundle\\UserBundle\\Entity\\UserManager $userManager */ $userManager = $this->container->get('oro_user.manager'); // Find role for user to able to authenticate in test. // You can use any available role that you want dependently on test logic. $role = $manager->getRepository(Role::class) ->findOneBy(['role' => 'IS_AUTHENTICATED_ANONYMOUSLY']); // Creating new user $user = $userManager->createUser(); // Creating API entity for user, we will reference it in testGetUsersAPI method, // if you are not going to test API you can skip it $api = new UserApi(); $api->setApiKey(self::USER_API_KEY) ->setUser($user); // Creating user $user ->setUsername(self::USER_NAME) ->setPlainPassword(self::USER_PASSWORD) // This value is referenced in testUsersIndex method ->setFirstName('Simple') ->setLastName('User') ->addRole($role) ->setEmail('test@example.com') ->setApi($api) ->setSalt(''); // Handle password encoding $userManager->updatePassword($user); $manager->persist($user); $manager->flush(); } } Tester les commandes : Lorsque Oroplatform est install\u00e9, vous pouvez tester les commandes en utilisant la m\u00e9thode runCommand() de la classe WebTestCase. Cette m\u00e9thode ex\u00e9cute une commande avec des param\u00e8tres donn\u00e9s et retourne sa sortie sous forme de cha\u00eene. Par exemple, voyez \u00e0 quoi ressemble le test pour la classe UpdateSchemaDoctrineListener du SearchBundle : namespace Oro\\Bundle\\SearchBundle\\Tests\\Functional\\EventListener; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class UpdateSchemaListenerTest extends WebTestCase { protected function setUp() { $this->initClient(); } /** * @dataProvider commandOptionsProvider */ public function testCommand($commandName, array $params, $expectedContent) { $result = $this->runCommand($commandName, $params); $this->assertContains($expectedContent, $result); } public function commandOptionsProvider() { return [ 'otherCommand' => [ 'commandName' => 'doctrine:mapping:info', 'params' => [], 'expectedContent' => 'OK' ], 'commandWithoutOption' => [ 'commandName' => 'doctrine:schema:update', 'params' => [], 'expectedContent' => 'Please run the operation by passing one - or both - of the following options:' ], 'commandWithAnotherOption' => [ 'commandName' => 'doctrine:schema:update', 'params' => ['--dump-sql' => true], 'expectedContent' => 'ALTER TABLE' ], 'commandWithForceOption' => [ 'commandName' => 'doctrine:schema:update', 'params' => ['--force' => true], 'expectedContent' => 'Schema update and create index completed' ] ]; } } VOIR AUSSI Lisez les Test des commandes dans la documentation officielle pour plus d\u2019informations sur la fa\u00e7on de tester les commandes dans une application Symfony. Tester les services ou les Repositories Pour tester des services ou des d\u00e9p\u00f4ts, vous pouvez acc\u00e9der au conteneur de service via la m\u00e9thode getContainer() : // src/Oro/Bundle/FooBarBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected $repositoryOrService; protected function setUp() { $this->initClient(); $this->loadFixtures(['Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\API\\DataFixtures\\LoadFooBarData']); $this->repositoryOrService = $this->getContainer()->get('repository_or_service_id'); } public function testMethod($commandName, array $params, $expectedContent) { $expected = 'test'; $this->assertEquals($expected, $this->repositoryOrService->callTestMethod()); } Example de test fonctionnel : Ceci est un exemple de la fa\u00e7on dont vous pouvez \u00e9crire un test d\u2019int\u00e9gration pour une classe qui utilise l\u2019ORM de doctrine sans moquer ses classes et en utilisant de vrais services de Doctrine : namespace Oro\\Bundle\\BatchBundle\\Tests\\Functional\\ORM\\QueryBuilder; use Doctrine\\ORM\\Query\\Expr\\Join; use Doctrine\\ORM\\QueryBuilder; use Doctrine\\ORM\\EntityManager; use Oro\\Bundle\\BatchBundle\\ORM\\QueryBuilder\\CountQueryBuilderOptimizer; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class CountQueryBuilderOptimizerTest extends WebTestCase { /** * @dataProvider getCountQueryBuilderDataProvider * @param QueryBuilder $queryBuilder * @param string $expectedDql */ public function testGetCountQueryBuilder(QueryBuilder $queryBuilder, $expectedDql) { $optimizer = new CountQueryBuilderOptimizer(); $countQb = $optimizer->getCountQueryBuilder($queryBuilder); $this->assertInstanceOf('Doctrine\\ORM\\QueryBuilder', $countQb); // Check for expected DQL $this->assertEquals($expectedDql, $countQb->getQuery()->getDQL()); // Check that Optimized DQL can be converted to SQL $this->assertNotEmpty($countQb->getQuery()->getSQL()); } /** * @return array */ public function getCountQueryBuilderDataProvider() { self::initClient(); $em = self::getContainer()->get('doctrine.orm.entity_manager'); return [ 'simple' => [ 'queryBuilder' => self::createQueryBuilder($em) ->from('OroUserBundle:User', 'u') ->select(['u.id', 'u.username']), 'expectedDQL' => 'SELECT u.id FROM OroUserBundle:User u' ], 'group_test' => [ 'queryBuilder' => self::createQueryBuilder($em) ->from('OroUserBundle:User', 'u') ->select(['u.id', 'u.username as uName']) ->groupBy('uName'), 'expectedDQL' => 'SELECT u.id, u.username as uName FROM OroUserBundle:User u GROUP BY uName' ] ); } /** * @param EntityManager $entityManager * @return QueryBuilder */ public static function createQueryBuilder(EntityManager $entityManager) { return new QueryBuilder($entityManager); } } Attention Si votre classe est responsable de la r\u00e9cup\u00e9ration des donn\u00e9es, il est pr\u00e9f\u00e9rable de charger les fixtures et de les r\u00e9cup\u00e9rer en utilisant une classe de test, puis d\u2019affirmer que les r\u00e9sultats sont valides. V\u00e9rifier le DQL suffit dans ce cas car c\u2019est la seule responsabilit\u00e9 de cette classe de modifier la requ\u00eate.","title":"Functionnal"},{"location":"tests/functional/#tests-fonctionnels","text":"Les tests fonctionnels permettent de v\u00e9rifier l\u2019int\u00e9gration des diff\u00e9rentes couches d\u2019une application. Dans cet article, vous apprendrez comment vous pouvez am\u00e9liorer l\u2019exp\u00e9rience de la r\u00e9daction de tests fonctionnels avec Oroplatform. Il est recommand\u00e9 de lire la Doc Symfony concernant les tests avant de continuer. Vous devriez \u00e9galement conna\u00eetre PhpUnit","title":"Tests fonctionnels"},{"location":"tests/functional/#quand-rediger-les-tests-fonctionnels","text":"Les tests fonctionnels sont g\u00e9n\u00e9ralement r\u00e9dig\u00e9s pour les : Contr\u00f4leurs Commandes D\u00e9p\u00f4ts Autres services L\u2019objectif des tests fonctionnels n\u2019est pas de tester des classes s\u00e9par\u00e9es (tests unitaires), mais de tester l\u2019int\u00e9gration des diff\u00e9rentes parties d\u2019une application. Ajouter des tests fonctionnels pour compl\u00e9ter les tests unitaires pour les raisons suivantes : Vous pouvez tester le syst\u00e8me multi-composants et vous assurer qu\u2019il fonctionne comme un tout. Vous pouvez \u00e9viter la simulation(mocking) de l\u2019interface compliqu\u00e9e ou de la couche de manipulation de donn\u00e9es (comme les classes de doctrine pour construire une requ\u00eate). Les tests unitaires peuvent r\u00e9ussir m\u00eame si les fonctionnalit\u00e9s ne fonctionnent pas correctement.","title":"Quand r\u00e9diger les tests fonctionnels"},{"location":"tests/functional/#environnement-de-test","text":"","title":"Environnement de test"},{"location":"tests/functional/#initialisation-du-client-et-avertissement-quand-aux-chargement-des-fixtures","text":"Pour am\u00e9liorer la performance de l\u2019ex\u00e9cution du test, l\u2019initialisation d\u2019un client n\u2019est effectu\u00e9e qu\u2019une seule fois par cas de test par d\u00e9faut. Cela signifie que le noyau de l\u2019application Symfony sera d\u00e9marr\u00e9 une fois par cas de test. Les fixtures sont \u00e9galement charg\u00e9s une seule fois par cas de test par d\u00e9faut. D\u2019une part, initialiser et charger des fixtures une fois par cas de test augmente la performance de l\u2019ex\u00e9cution de test mais peut aussi causer des bugs car l\u2019\u00e9tat des fixtures et du noyau (et par cons\u00e9quent, le conteneur de service) sera partag\u00e9 par d\u00e9faut entre les m\u00e9thodes de test de cas de test s\u00e9par\u00e9s. Assurez-vous de r\u00e9initialiser cet \u00e9tat si n\u00e9cessaire.","title":"Initialisation du client et avertissement quand aux chargement des fixtures"},{"location":"tests/functional/#configuration-dun-environnement-de-test","text":"Vous devez configurer les param\u00e8tres suivants pour l\u2019environnement de test : Cr\u00e9er une base de donn\u00e9es distincte pour les tests (p. ex., ajouter le suffixe \u00ab _test \u00bb) : Configurez les param\u00e8tres h\u00f4te, port et authentification pour la base de donn\u00e9es, le serveur de messagerie et le serveur de socket web dans le fichier parameters_test.yml : Par exemple : # config/parameters_test.yml parameters: database_host: 127.0.0.1 database_port: null database_name: crm_test database_user: root database_password: null mailer_transport: smtp mailer_host: 127.0.0.1 mailer_port: null mailer_encryption: null mailer_user: null mailer_password: null session_handler: null locale: en secret: ThisTokenIsNotSoSecretChangeIt installed: false Installez l'application dans un environnement de test bin/console oro:install \\ --env=test \\ --organization-name=Oro \\ --user-name=admin \\ --user-email=admin@example.com \\ --user-firstname=John \\ --user-lastname=Doe \\ --user-password=admin \\ --sample-data=n \\ --application-url=http://localhost Lors de l\u2019installation, la structure de la base de donn\u00e9es est configur\u00e9e et les fixtures standard sont charg\u00e9s. Ex\u00e9cuter les tests en utilisant phpunit avec l\u2019option \u2013testsuite appropri\u00e9e (unit ou functionnal). ATTENTION Actuellement, l\u2019ex\u00e9cution de diff\u00e9rents types de tests automatis\u00e9s ensemble n\u2019est pas prise en charge. Il est donc fortement d\u00e9conseill\u00e9 d\u2019ex\u00e9cuter des tests unitaires et des tests fonctionnels c\u00f4te \u00e0 c\u00f4te en une seule ex\u00e9cution, car cela produit des erreurs. Les tests unitaires cr\u00e9ent des objets fictifs qui interf\u00e8rent ult\u00e9rieurement avec l\u2019ex\u00e9cution des tests fonctionnels et cr\u00e9ent une ambigu\u00eft\u00e9 inutile. Il est possible de d\u00e9sactiver les tests unitaires au d\u00e9marrage du test \u00e0 l\u2019aide de l\u2019option testsuite : $ php bin/phpunit -c . / --testsuite=functional $ php bin/phpunit -c . / --testsuite=unit","title":"Configuration d'un environnement de test"},{"location":"tests/functional/#database-isolation","text":"L'annotation @dbIsolationPerTest ajoute une transaction qui sera effectu\u00e9e avant le d\u00e9but d\u2019un test et qui est annul\u00e9e lorsqu\u2019un test se termine. // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; /** * @dbIsolationPerTest */ class FooBarTest extends WebTestCase { // ... }","title":"Database Isolation"},{"location":"tests/functional/#chargement-des-data-fixtures","text":"Utilisez la m\u00e9thode loadFixtures() pour charger des donn\u00e9es dans un test : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { $this->initClient(); // must be called before! // loading fixtures will be executed once, use the second parameter // $force = true to force the loading $this->loadFixtures([ 'Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadFooData', '@OroFooBarBundle/Tests/Functional/DataFixtures/bar_data.yml', ]); } // ... } Un fixture doit \u00eatre soit un nom de classe qui impl\u00e9mente Doctrine\\Common\\DataFixtures\\FixtureInterface , soit un chemin vers le fichier nelmio/alice. Un exemple de fixture : // src/Oro/Bundle/FooBarBundle/Tests/Functional/DataFixtures/LoadFooData.php namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Oro\\Bundle\\FooBarBundle\\Entity\\FooEntity; class LoadFooData extends AbstractFixture { public function load(ObjectManager $manager) { $entity = new FooEntity(); $manager->persist($entity); $manager->flush(); } } # src/Oro/Bundle/FooBarBundle/Tests/Functional/DataFixtures/bar_data.yml Oro\\Bundle\\FooBarBundle\\Entity\\BarEntity: bar: name: test Vous pouvez \u00e9galement impl\u00e9menter l\u2019interfaceDoctrine\\Common\\DataFixtures\\DependentFixtureInterface qui permet de charger des fixtures en fonction des autres fixtures d\u00e9j\u00e0 charg\u00e9es : // src/Oro/Bundle/FooBarBundle/Tests/Functional/DataFixtures/LoadFooData.php namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\DataFixtures\\DependentFixtureInterface; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; class LoadFooData extends AbstractFixture implements DependentFixtureInterface { public function load(ObjectManager $manager) { // load fixtures } public function getDependencies() { return ['Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadBarData']; } } De plus, vous pouvez utiliser des entit\u00e9s sp\u00e9cifiques aux r\u00e9f\u00e9rences \u00e0 partir de fixtures, par exemple : namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\Persistence\\ObjectManager; use Doctrine\\Common\\DataFixtures\\DependentFixtureInterface; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Oro\\Bundle\\FooBarBundle\\Entity\\FooEntity; class LoadFooData extends AbstractFixture implements DependentFixtureInterface { public function load(ObjectManager $manager) { $entity = new FooEntity(); $manager->persist($entity); $manager->flush(); $this->addReference('my_entity', $entity); } public function getDependencies() { return ['Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadBarData']; } } Maintenant, vous pouvez r\u00e9f\u00e9rencer le fixture par le nom configur\u00e9 dans votre test : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected $entity; protected function setUp() { $this->initClient(); $this->loadFixtures('Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\DataFixtures\\LoadFooData'); $this->entity = $this->getReference('my_entity'); } // ... }","title":"Chargement des data fixtures :"},{"location":"tests/functional/#notes","text":"Par d\u00e9faut, le gestionnaire d\u2019entit\u00e9s est effac\u00e9 apr\u00e8s le chargement de chaque fixture. Pour \u00e9viter le nettoyage une fixture peut impl\u00e9menterOro\\Bundle\\TestFrameworkBundle\\Test\\DataFixtures\\InitialFixtureInterface. Parfois, vous avez besoin d\u2019une r\u00e9f\u00e9rence \u00e0 l\u2019Organization, d'un User ou d'une BusinessUnit. Les fixtures suivants peuvent \u00eatre utilis\u00e9s pour les charger : Oro\\Bundle\\TestFrameworkBundle\\Tests\\Functional\\DataFixtures\\LoadOrganization Oro\\Bundle\\TestFrameworkBundle\\Tests\\Functional\\DataFixtures\\LoadUser Oro\\Bundle\\TestFrameworkBundle\\Tests\\Functional\\DataFixtures\\LoadBusinessUnit","title":"NOTES :"},{"location":"tests/functional/#ecrire-des-test-fonctionnel","text":"Pour cr\u00e9er un test fonctionel : Etendez la classe WebTestCase Pr\u00e9parez une instance de la classe Client Pr\u00e9parez vos fixtures ( Optionnel) Pr\u00e9parez le container Appelez les fonctionnalit\u00e9es du test 6 V\u00e9rifiez le r\u00e9sultat","title":"Ecrire des test fonctionnel :"},{"location":"tests/functional/#tests-fonctionnel-pour-les-controlleurs","text":"Un test fonctionnel pour un contr\u00f4leur se compose de quelques \u00e9tapes: Faire une requete Tester la r\u00e9ponse Cliquez sur un lien ou soumettez un formulaire Test the response Nettoyer et r\u00e9p\u00e9ter","title":"Tests fonctionnel pour les controlleurs :"},{"location":"tests/functional/#exemples-de-prepraration-du-client","text":"L\u2019initialisation simple fonctionne pour tester les commandes et les services lorsque l\u2019authentification n\u2019est pas n\u00e9cessaire. // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { $this->initClient(); // initialization occurres only once per test class // now varialbe $this->client is available } // ... } Initialisation avec les options Appkernel personnalis\u00e9es : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { // first array is Kernel options $this->initClient(['debug' => false]); } // ... } Initialisation avec authentification : // src/Oro/Bundle/FooBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected function setUp() { // second array is service options // this example will create client with server options ['PHP_AUTH_USER' => 'admin@example.com', 'PHP_AUTH_PW' => 'admin'] // make sure you loaded fixture with test user // bin/console doctrine:fixture:load --no-debug --append --no-interaction --env=test --fixtures src/Oro/src/Oro/Bundle/TestFrameworkBundle/Fixtures $this->initClient([], $this->generateBasicAuthHeader()); // init client with custom username and password $this->initClient([], $this->generateBasicAuthHeader('custom_username', 'custom_password')); } // ... }","title":"Exemples de pr\u00e9praration du client :"},{"location":"tests/functional/#types-de-tests-fonctionnels","text":"","title":"Types de tests fonctionnels"},{"location":"tests/functional/#tester-les-controllers","text":"// src/OroCRM/Bundle/TaskBundle/Tests/Functional/Controller/TaskControllersTest.php namespace Oro\\Bundle\\TaskBundle\\Tests\\Functional\\Controller; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; /** * @outputBuffering enabled */ class TaskControllersTest extends WebTestCase { protected function setUp() { $this->initClient([], $this->generateBasicAuthHeader()); } public function testCreate() { $crawler = $this->client->request('GET', $this->getUrl('orocrm_task_create')); $form = $crawler->selectButton('Save and Close')->form(); $form['orocrm_task[subject]'] = 'New task'; $form['orocrm_task[description]'] = 'New description'; $form['orocrm_task[dueDate]'] = '2014-03-04T20:00:00+0000'; $form['orocrm_task[owner]'] = '1'; $form['orocrm_task[reporter]'] = '1'; $this->client->followRedirects(true); $crawler = $this->client->submit($form); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task saved', $crawler->html()); } /** * @depends testCreate */ public function testUpdate() { $response = $this->client->requestGrid( 'tasks-grid', ['tasks-grid[_filter][reporterName][value]' => 'John Doe'] ); $result = $this->getJsonResponseContent($response, 200); $result = reset($result['data']); $crawler = $this->client->request( 'GET', $this->getUrl('orocrm_task_update', ['id' => $result['id']]) ); $form = $crawler->selectButton('Save and Close')->form(); $form['orocrm_task[subject]'] = 'Task updated'; $form['orocrm_task[description]'] = 'Description updated'; $this->client->followRedirects(true); $crawler = $this->client->submit($form); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task saved', $crawler->html()); } /** * @depends testUpdate */ public function testView() { $response = $this->client->requestGrid( 'tasks-grid', ['tasks-grid[_filter][reporterName][value]' => 'John Doe'] ); $result = $this->getJsonResponseContent($response, 200); $result = reset($result['data']); $this->client->request( 'GET', $this->getUrl('orocrm_task_view', ['id' => $result['id']]) ); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task updated - Tasks - Activities', $result->getContent()); } /** * @depends testUpdate */ public function testIndex() { $this->client->request('GET', $this->getUrl('orocrm_task_index')); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 200); $this->assertContains('Task updated', $result->getContent()); } }","title":"Tester les controllers"},{"location":"tests/functional/#tester-les-acls-dans-les-controlleurs","text":"Dans cet exemple, un utilisateur sans autorisations suffisantes essaie d\u2019acc\u00e9der \u00e0 une action du contr\u00f4leur. La m\u00e9thode assertHtmlResponseStatusCodeEquals() est utilis\u00e9e pour s\u2019assurer que l\u2019acc\u00e8s \u00e0 la ressource demand\u00e9e est refus\u00e9 \u00e0 l\u2019utilisateur : namespace Oro\\Bundle\\UserBundle\\Tests\\Functional; use Oro\\Bundle\\UserBundle\\Tests\\Functional\\DataFixtures\\LoadUserData; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; /** * @outputBuffering enabled */ class UsersTest extends WebTestCase { protected function setUp() { $this->initClient(); $this->loadFixtures(['Oro\\Bundle\\UserBundle\\Tests\\Functional\\API\\DataFixtures\\LoadUserData']); } public function testUsersIndex() { $this->client->request( 'GET', $this->getUrl('oro_user_index'), [], [], $this->generateBasicAuthHeader(LoadUserData::USER_NAME, LoadUserData::USER_PASSWORD) ); $result = $this->client->getResponse(); $this->assertHtmlResponseStatusCodeEquals($result, 403); } public function testGetUsersAPI() { $this->client->request( 'GET', $this->getUrl('oro_api_get_users'), ['limit' => 100], [], $this->generateWsseAuthHeader(LoadUserData::USER_NAME, LoadUserData::USER_API_KEY) ); $result = $this->client->getResponse(); $this->assertJsonResponseStatusCodeEquals($result, 403); } } Voici un exemple de fixture qui ajoute un utilisateur sans permission : / src/Oro/Bundle/UserBundle/Tests/Functional/DataFixtures/LoadUserData.php namespace Oro\\Bundle\\UserBundle\\Tests\\Functional\\DataFixtures; use Doctrine\\Common\\DataFixtures\\AbstractFixture; use Doctrine\\Common\\Persistence\\ObjectManager; use Symfony\\Component\\DependencyInjection\\ContainerAwareInterface; use Symfony\\Component\\DependencyInjection\\ContainerInterface; use Oro\\Bundle\\UserBundle\\Entity\\Role; use Oro\\Bundle\\UserBundle\\Entity\\UserApi; class LoadUserData extends AbstractFixture implements ContainerAwareInterface { const USER_NAME = 'user_wo_permissions'; const USER_API_KEY = 'user_api_key'; const USER_PASSWORD = 'user_password'; private $container; public function setContainer(ContainerInterface $container = null) { $this->container = $container; } public function load(ObjectManager $manager) { /** @var \\Oro\\Bundle\\UserBundle\\Entity\\UserManager $userManager */ $userManager = $this->container->get('oro_user.manager'); // Find role for user to able to authenticate in test. // You can use any available role that you want dependently on test logic. $role = $manager->getRepository(Role::class) ->findOneBy(['role' => 'IS_AUTHENTICATED_ANONYMOUSLY']); // Creating new user $user = $userManager->createUser(); // Creating API entity for user, we will reference it in testGetUsersAPI method, // if you are not going to test API you can skip it $api = new UserApi(); $api->setApiKey(self::USER_API_KEY) ->setUser($user); // Creating user $user ->setUsername(self::USER_NAME) ->setPlainPassword(self::USER_PASSWORD) // This value is referenced in testUsersIndex method ->setFirstName('Simple') ->setLastName('User') ->addRole($role) ->setEmail('test@example.com') ->setApi($api) ->setSalt(''); // Handle password encoding $userManager->updatePassword($user); $manager->persist($user); $manager->flush(); } }","title":"Tester les ACLs dans les controlleurs :"},{"location":"tests/functional/#tester-les-commandes","text":"Lorsque Oroplatform est install\u00e9, vous pouvez tester les commandes en utilisant la m\u00e9thode runCommand() de la classe WebTestCase. Cette m\u00e9thode ex\u00e9cute une commande avec des param\u00e8tres donn\u00e9s et retourne sa sortie sous forme de cha\u00eene. Par exemple, voyez \u00e0 quoi ressemble le test pour la classe UpdateSchemaDoctrineListener du SearchBundle : namespace Oro\\Bundle\\SearchBundle\\Tests\\Functional\\EventListener; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class UpdateSchemaListenerTest extends WebTestCase { protected function setUp() { $this->initClient(); } /** * @dataProvider commandOptionsProvider */ public function testCommand($commandName, array $params, $expectedContent) { $result = $this->runCommand($commandName, $params); $this->assertContains($expectedContent, $result); } public function commandOptionsProvider() { return [ 'otherCommand' => [ 'commandName' => 'doctrine:mapping:info', 'params' => [], 'expectedContent' => 'OK' ], 'commandWithoutOption' => [ 'commandName' => 'doctrine:schema:update', 'params' => [], 'expectedContent' => 'Please run the operation by passing one - or both - of the following options:' ], 'commandWithAnotherOption' => [ 'commandName' => 'doctrine:schema:update', 'params' => ['--dump-sql' => true], 'expectedContent' => 'ALTER TABLE' ], 'commandWithForceOption' => [ 'commandName' => 'doctrine:schema:update', 'params' => ['--force' => true], 'expectedContent' => 'Schema update and create index completed' ] ]; } }","title":"Tester les commandes :"},{"location":"tests/functional/#voir-aussi","text":"Lisez les Test des commandes dans la documentation officielle pour plus d\u2019informations sur la fa\u00e7on de tester les commandes dans une application Symfony.","title":"VOIR AUSSI"},{"location":"tests/functional/#tester-les-services-ou-les-repositories","text":"Pour tester des services ou des d\u00e9p\u00f4ts, vous pouvez acc\u00e9der au conteneur de service via la m\u00e9thode getContainer() : // src/Oro/Bundle/FooBarBundle/Tests/Functional/FooBarTest.php namespace Oro\\Bundle\\FooBarBundle\\Tests\\Functional; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class FooBarTest extends WebTestCase { protected $repositoryOrService; protected function setUp() { $this->initClient(); $this->loadFixtures(['Oro\\Bundle\\FooBarBundle\\Tests\\Functional\\API\\DataFixtures\\LoadFooBarData']); $this->repositoryOrService = $this->getContainer()->get('repository_or_service_id'); } public function testMethod($commandName, array $params, $expectedContent) { $expected = 'test'; $this->assertEquals($expected, $this->repositoryOrService->callTestMethod()); }","title":"Tester les services ou les Repositories"},{"location":"tests/functional/#example-de-test-fonctionnel","text":"Ceci est un exemple de la fa\u00e7on dont vous pouvez \u00e9crire un test d\u2019int\u00e9gration pour une classe qui utilise l\u2019ORM de doctrine sans moquer ses classes et en utilisant de vrais services de Doctrine : namespace Oro\\Bundle\\BatchBundle\\Tests\\Functional\\ORM\\QueryBuilder; use Doctrine\\ORM\\Query\\Expr\\Join; use Doctrine\\ORM\\QueryBuilder; use Doctrine\\ORM\\EntityManager; use Oro\\Bundle\\BatchBundle\\ORM\\QueryBuilder\\CountQueryBuilderOptimizer; use Oro\\Bundle\\TestFrameworkBundle\\Test\\WebTestCase; class CountQueryBuilderOptimizerTest extends WebTestCase { /** * @dataProvider getCountQueryBuilderDataProvider * @param QueryBuilder $queryBuilder * @param string $expectedDql */ public function testGetCountQueryBuilder(QueryBuilder $queryBuilder, $expectedDql) { $optimizer = new CountQueryBuilderOptimizer(); $countQb = $optimizer->getCountQueryBuilder($queryBuilder); $this->assertInstanceOf('Doctrine\\ORM\\QueryBuilder', $countQb); // Check for expected DQL $this->assertEquals($expectedDql, $countQb->getQuery()->getDQL()); // Check that Optimized DQL can be converted to SQL $this->assertNotEmpty($countQb->getQuery()->getSQL()); } /** * @return array */ public function getCountQueryBuilderDataProvider() { self::initClient(); $em = self::getContainer()->get('doctrine.orm.entity_manager'); return [ 'simple' => [ 'queryBuilder' => self::createQueryBuilder($em) ->from('OroUserBundle:User', 'u') ->select(['u.id', 'u.username']), 'expectedDQL' => 'SELECT u.id FROM OroUserBundle:User u' ], 'group_test' => [ 'queryBuilder' => self::createQueryBuilder($em) ->from('OroUserBundle:User', 'u') ->select(['u.id', 'u.username as uName']) ->groupBy('uName'), 'expectedDQL' => 'SELECT u.id, u.username as uName FROM OroUserBundle:User u GROUP BY uName' ] ); } /** * @param EntityManager $entityManager * @return QueryBuilder */ public static function createQueryBuilder(EntityManager $entityManager) { return new QueryBuilder($entityManager); } }","title":"Example de test fonctionnel :"},{"location":"tests/functional/#attention","text":"Si votre classe est responsable de la r\u00e9cup\u00e9ration des donn\u00e9es, il est pr\u00e9f\u00e9rable de charger les fixtures et de les r\u00e9cup\u00e9rer en utilisant une classe de test, puis d\u2019affirmer que les r\u00e9sultats sont valides. V\u00e9rifier le DQL suffit dans ce cas car c\u2019est la seule responsabilit\u00e9 de cette classe de modifier la requ\u00eate.","title":"Attention"},{"location":"tests/intro/","text":"Les tests unitaires et fonctionnels, qui aident \u00e0 tester l\u2019architecture d\u2019application et les API de programmation. Cependant, ces types de tests donnent aux d\u00e9veloppeurs aucune garantie que lorsque l\u2019utilisateur ouvre une page, tout va fonctionner comme pr\u00e9vu. Pour cette raison, le framework Behavior-Driven nomm\u00e9 Behat est utilis\u00e9, qui au lieu de compter sur le code source se comporte comme un utilisateur r\u00e9el. Il peut tr\u00e8s bien \u00e9muler l\u2019utilisateur, ex\u00e9cuter des tests dans un v\u00e9ritable navigateur Web, et utilise un langage sp\u00e9cifique et lisible par tout le monde appel\u00e9 Gherkin pour d\u00e9crire les tests. Tests fonctionnels Tests Behat Tests Javascript Le projet original est sous license CC-BY-NC-SA 4.0 La documentation original est publi\u00e9 ici : Doc original Cette documentation est elle aussi sous license CC-BY-NC-SA 4.0","title":"Intro"},{"location":"tests/javascript/","text":"Test unitaire Javascript Installation Les logiciel suivant sont n\u00e9cessaire pour ex\u00e9cuter les tests JS : Node.js (Moteur JavaScript) Karma (Lanceur de test Javascript) Jasmine 3.5 (Framework BDD) NOTE Pour obtenir des instructions sur la fa\u00e7on d\u2019installer Node.js, acc\u00e9dez au site officiel . Une fois Node install\u00e9, installez plusieurs modules en utilisant Node Packaged Modules en ex\u00e9cutant la commande suivante \u00e0 partir du dossier racine de votre application npm install --prefix=vendor/oro/platform/build O\u00f9 le param\u00e8tre \u2013prefix sp\u00e9cifie le chemin relatif au r\u00e9pertoire platform/build. Configuration La configuration pour lancer les tests et dans build/karma.config.js.dist. Note Voir plus d\u2019informations dans la documentation officielle de Karma . Il peut \u00eatre utile de cr\u00e9er une configuration s\u00e9par\u00e9 en copiant ./vendor/oro/platform/build/karma.config.js.dist vers ./vendor/oro/platform/build/karma.config.js et le modifier. Lancement Pour ex\u00e9cuter des tests, appelez la commande suivante : ./vendor/oro/platform/build/node_modules/.bin/karma start ./vendor/oro/platform/build/karma.conf.js.dist --single-run N\u2019oubliez pas de changer le chemin vers le r\u00e9pertoire de plateform/build, s\u2019il est diff\u00e9rent dans votre application. ` Pour ex\u00e9cuter une testsuite avec une configuration personnalis\u00e9e, vous pouvez utiliser les param\u00e8tres de ligne de commande qui \u00e9crasent les param\u00e8tres dans le fichier de configuration. Quelques options personnalis\u00e9es ont \u00e9t\u00e9 ajout\u00e9es pour pr\u00e9parer la configuration de Karma : \u2013mask string file masque pour les fichiers Spec.Par d\u00e9fault c'est vendor/oro/**/Tests/JS/**/*Spec.js qui correspond \u00e0 tous les fichiers Spec du projet dans le r\u00e9pertoire vendor oro. \u2013spec string chemin vers un fichier de Spec sp\u00e9cifique, s\u2019il est pass\u00e9, alors la recherche par masque est ignor\u00e9e et le test est ex\u00e9cut\u00e9 fichier Spec unique. \u2013skip-indexing boolean permet de sauter la phase de la collecte des fichiers de sp\u00e9cifications et de r\u00e9utiliser la collection des des lancements pr\u00e9c\u00e9dent. \u2013theme string le nom du th\u00e8me est utilis\u00e9 pour g\u00e9n\u00e9rer la configuration de webpack pour certains th\u00e8mes. Par d\u00e9faut, c\u2019est `admin.oro. Les extensions suivantes peuvent \u00eatre utiles si vous utilisez Phpstorm: Le plugin Karma aide \u00e0 ex\u00e9cuter des testsuite \u00e0 partir de l\u2019IDE et voir les r\u00e9sultats facilement. ddescriber pour jasmin aide \u00e0 d\u00e9sactiver ou \u00e0 sauter certains tests de la testsuite rapidement R\u00e9daction NOTE Voir la documentation de Jasmine 3.5 pour de plus amples renseignements sur la r\u00e9daction de tests avec Jasmine 3.5. L\u2019exemple ci-dessous illustre les sp\u00e9cifications du module oroui/js/mediator : import mediator from 'oroui/js/mediator'; import Backbone from 'backbone'; describe('oroui/js/mediator', function () { it(\"compare mediator to Backbone.Events\", function() { expect(mediator).toEqual(Backbone.Events); expect(mediator).not.toBe(Backbone.Events); }); }); karma-jsmodule-exposure Cette approche permet de tester l\u2019API publique d\u2019un module. Mais vous pouvez utilisez le plugin karma-jsmodule-exposure pour injecter du code exposant \u00e0 l\u2019int\u00e9rieur du js-module et fournit l\u2019API pour manipuler les variables internes : import someModule from 'some/module'; import jsmoduleExposure from 'jsmodule-exposure'; // get exposure instance for tested module var exposure = jsmoduleExposure.disclose('some/module'); describe('some/module', function () { var foo; beforeEach(function () { // create mock object with stub method 'do' foo = jasmine.createSpyObj('foo', ['do']); // before each test, pass it off instead of original exposure.substitute('foo').by(foo); }); afterEach(function () { // after each test restore original value of foo exposure.recover('foo'); }); it('check doSomething() method', function() { someModule.doSomething(); // stub method of mock object has been called expect(foo.do).toHaveBeenCalled(); }); }); Jasmine-jQuery Jasmine-jQuery \u00e9tend la fonctionnalit\u00e9 de base de Jasmine, en particulier : ajoute un certain nombre de matchers utiles, et permet de v\u00e9rifier l\u2019\u00e9tat d\u2019une instance jQuery facilement applique des fixtures HTML avant chaque test et retourne le document apr\u00e8s les tests fournit un moyen de charger les fixtures HTML et JSON n\u00e9cessaires pour un test Cependant, parce que Jasmine-jQuery n\u00e9cessite le chemin complet vers une ressource fixture, il est pr\u00e9f\u00e9rable d\u2019utiliser import pour charger les fixtures par un chemin connexe. import 'jasmine-jquery'; import $ from 'jquery'; import html from 'text-loader!./Fixture/markup.html'; describe('some/module', function () { beforeEach(function () { // appends loaded html to document's body, // after test rolls back it automatically window.setFixtures(html); }); it('checks the markup of a page', function () { expect($('li')).toHaveLength(5); }); });","title":"Javascript"},{"location":"tests/javascript/#test-unitaire-javascript","text":"","title":"Test unitaire Javascript"},{"location":"tests/javascript/#installation","text":"Les logiciel suivant sont n\u00e9cessaire pour ex\u00e9cuter les tests JS : Node.js (Moteur JavaScript) Karma (Lanceur de test Javascript) Jasmine 3.5 (Framework BDD)","title":"Installation"},{"location":"tests/javascript/#note","text":"Pour obtenir des instructions sur la fa\u00e7on d\u2019installer Node.js, acc\u00e9dez au site officiel . Une fois Node install\u00e9, installez plusieurs modules en utilisant Node Packaged Modules en ex\u00e9cutant la commande suivante \u00e0 partir du dossier racine de votre application npm install --prefix=vendor/oro/platform/build O\u00f9 le param\u00e8tre \u2013prefix sp\u00e9cifie le chemin relatif au r\u00e9pertoire platform/build.","title":"NOTE"},{"location":"tests/javascript/#configuration","text":"La configuration pour lancer les tests et dans build/karma.config.js.dist.","title":"Configuration"},{"location":"tests/javascript/#note_1","text":"Voir plus d\u2019informations dans la documentation officielle de Karma . Il peut \u00eatre utile de cr\u00e9er une configuration s\u00e9par\u00e9 en copiant ./vendor/oro/platform/build/karma.config.js.dist vers ./vendor/oro/platform/build/karma.config.js et le modifier.","title":"Note"},{"location":"tests/javascript/#lancement","text":"Pour ex\u00e9cuter des tests, appelez la commande suivante : ./vendor/oro/platform/build/node_modules/.bin/karma start ./vendor/oro/platform/build/karma.conf.js.dist --single-run N\u2019oubliez pas de changer le chemin vers le r\u00e9pertoire de plateform/build, s\u2019il est diff\u00e9rent dans votre application. ` Pour ex\u00e9cuter une testsuite avec une configuration personnalis\u00e9e, vous pouvez utiliser les param\u00e8tres de ligne de commande qui \u00e9crasent les param\u00e8tres dans le fichier de configuration. Quelques options personnalis\u00e9es ont \u00e9t\u00e9 ajout\u00e9es pour pr\u00e9parer la configuration de Karma : \u2013mask string file masque pour les fichiers Spec.Par d\u00e9fault c'est vendor/oro/**/Tests/JS/**/*Spec.js qui correspond \u00e0 tous les fichiers Spec du projet dans le r\u00e9pertoire vendor oro. \u2013spec string chemin vers un fichier de Spec sp\u00e9cifique, s\u2019il est pass\u00e9, alors la recherche par masque est ignor\u00e9e et le test est ex\u00e9cut\u00e9 fichier Spec unique. \u2013skip-indexing boolean permet de sauter la phase de la collecte des fichiers de sp\u00e9cifications et de r\u00e9utiliser la collection des des lancements pr\u00e9c\u00e9dent. \u2013theme string le nom du th\u00e8me est utilis\u00e9 pour g\u00e9n\u00e9rer la configuration de webpack pour certains th\u00e8mes. Par d\u00e9faut, c\u2019est `admin.oro. Les extensions suivantes peuvent \u00eatre utiles si vous utilisez Phpstorm: Le plugin Karma aide \u00e0 ex\u00e9cuter des testsuite \u00e0 partir de l\u2019IDE et voir les r\u00e9sultats facilement. ddescriber pour jasmin aide \u00e0 d\u00e9sactiver ou \u00e0 sauter certains tests de la testsuite rapidement","title":"Lancement"},{"location":"tests/javascript/#redaction","text":"","title":"R\u00e9daction"},{"location":"tests/javascript/#note_2","text":"Voir la documentation de Jasmine 3.5 pour de plus amples renseignements sur la r\u00e9daction de tests avec Jasmine 3.5. L\u2019exemple ci-dessous illustre les sp\u00e9cifications du module oroui/js/mediator : import mediator from 'oroui/js/mediator'; import Backbone from 'backbone'; describe('oroui/js/mediator', function () { it(\"compare mediator to Backbone.Events\", function() { expect(mediator).toEqual(Backbone.Events); expect(mediator).not.toBe(Backbone.Events); }); });","title":"NOTE"},{"location":"tests/javascript/#karma-jsmodule-exposure","text":"Cette approche permet de tester l\u2019API publique d\u2019un module. Mais vous pouvez utilisez le plugin karma-jsmodule-exposure pour injecter du code exposant \u00e0 l\u2019int\u00e9rieur du js-module et fournit l\u2019API pour manipuler les variables internes : import someModule from 'some/module'; import jsmoduleExposure from 'jsmodule-exposure'; // get exposure instance for tested module var exposure = jsmoduleExposure.disclose('some/module'); describe('some/module', function () { var foo; beforeEach(function () { // create mock object with stub method 'do' foo = jasmine.createSpyObj('foo', ['do']); // before each test, pass it off instead of original exposure.substitute('foo').by(foo); }); afterEach(function () { // after each test restore original value of foo exposure.recover('foo'); }); it('check doSomething() method', function() { someModule.doSomething(); // stub method of mock object has been called expect(foo.do).toHaveBeenCalled(); }); });","title":"karma-jsmodule-exposure"},{"location":"tests/javascript/#jasmine-jquery","text":"Jasmine-jQuery \u00e9tend la fonctionnalit\u00e9 de base de Jasmine, en particulier : ajoute un certain nombre de matchers utiles, et permet de v\u00e9rifier l\u2019\u00e9tat d\u2019une instance jQuery facilement applique des fixtures HTML avant chaque test et retourne le document apr\u00e8s les tests fournit un moyen de charger les fixtures HTML et JSON n\u00e9cessaires pour un test Cependant, parce que Jasmine-jQuery n\u00e9cessite le chemin complet vers une ressource fixture, il est pr\u00e9f\u00e9rable d\u2019utiliser import pour charger les fixtures par un chemin connexe. import 'jasmine-jquery'; import $ from 'jquery'; import html from 'text-loader!./Fixture/markup.html'; describe('some/module', function () { beforeEach(function () { // appends loaded html to document's body, // after test rolls back it automatically window.setFixtures(html); }); it('checks the markup of a page', function () { expect($('li')).toHaveLength(5); }); });","title":"Jasmine-jQuery"}]}